{"pageProps":{"metaData":{"title":"凸包-地图围栏","description":"公司零售货柜机在地图上的点需要围栏圈起来，以便显示大致范围","tags":["算法"],"keywords":["算法"],"id":"凸包-地图围栏-二分算法","create":1682416219035,"lastUpdate":1686904275590},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"凸包算法-地图围栏\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"公司零售货柜机在地图上的点需要围栏圈起来，以便显示大致范围\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"\\n/**\\n *      p2\\n *  p1<\\n *      p3\\n * 叉积判断 p1p2 p1p3\\n * | p2.x-p1.x | p2.y-p1.y |\\n * | p3.x-p1.x | p3.y-p1.y |\\n * @param {{x:number,y:number}} p1 \\n * @param {{x:number,y:number}} p2 \\n * @param {{x:number,y:number}} p3 \\n */\\nfunction crossProduct(p1, p2, p3) {\\n  return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);\\n}\\n\\n/**\\n * \\n * @param {{x:number,y:number}[]} points \\n */\\nfunction getConvexHull(points) {\\n\\n  if (points.length <= 1) { return points; }\\n\\n  //按照x坐标排序 \\n  points.sort((a, b) => a.x - b.x || a.y - b.y);\\n  let lowerHull = [];\\n  for (let i = 0; i < points.length; i++) {\\n    //构建下凸包\\n\\n    // 遍历凸包数据集判断当前点Pi是否在 H(n-2)H(n-1)的内侧(叉积<0)，如果在内侧就移除H(n-1) \\n    while (\\n      lowerHull.length >= 2 && \\n      crossProduct(lowerHull[lowerHull.length - 2], lowerHull[lowerHull.length - 1], points[i]) <= 0\\n    ) {\\n      lowerHull.pop();\\n    }\\n    lowerHull.push(points[i]);\\n  }\\n  let upperHull = [];\\n  for (let i = points.length - 1; i >= 0; i--) {\\n    //构建上凸包\\n    while (\\n      upperHull.length >= 2 && \\n      crossProduct(upperHull[upperHull.length - 2], upperHull[upperHull.length - 1], points[i]) <= 0) {\\n      upperHull.pop();\\n    }\\n    upperHull.push(points[i]);\\n  }\\n  //合并上下凸包 \\n  upperHull.pop();\\n  lowerHull.pop();\\n  return lowerHull.concat(upperHull);\\n}\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}