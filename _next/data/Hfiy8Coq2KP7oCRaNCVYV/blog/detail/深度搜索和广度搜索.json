{"pageProps":{"metaData":{"title":"深度搜索和广度搜索","description":"深度搜索和广度搜索学习","tags":["算法","深度搜索","广度搜索"],"keywords":["算法","深度搜索","广度搜索"],"id":"深度搜索和广度搜索","create":1692955580388,"lastUpdate":1692955580427},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    h3: \"h3\",\n    h4: \"h4\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"深度搜索和广度搜索\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"DFS 和 BFS 在图的遍历中具有不同的特点。DFS 可以更深入地探索图的分支，适用于查找路径或遍历整个连通图。而 BFS 则逐层地扫描图的节点，适用于查找最短路径或按层级遍历图结构\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"深度搜索\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"深度搜索 (Depth-First Search,DFS) 是一种以深度为优先的搜索算法。它从起始节点开始，沿着路径依次探索直到达到最深处，然后回溯到上一层节点，继续向未探索的分支探索，直到遍历完整个图。DFS 通常使用递归或栈数据结构来实现。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"以下是 DFS 的基本思想：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"从起始节点开始，将其标记为已访问。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"遍历当前节点的相邻节点，选择一个未访问过的节点作为下一个要探索的节点。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"重复步骤 2 直到无法继续前进，然后回溯到上一层节点，继续探索未访问的节点。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"重复步骤 2 和步骤 3 直到遍历完整个图。\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"场景\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"图遍历：DFS 可以用来遍历图中的所有节点，查找路径、环路或进行连通性检测。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"拓扑排序：DFS 可以通过深度优先遍历对有向无环图（DAG）进行拓扑排序，确定任务执行的顺序。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"迷宫求解：DFS 可以用于解决迷宫问题，通过从起点开始，深度地搜索直到找到终点。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"解决数独等组合问题：DFS 可以用于解决数独等需要进行组合尝试的问题，递归地尝试每个位置的可能值。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts:深度搜索\",\n        children: \"\\n  let test = [\\n    {\\n      id: 84, //标签id\\n      name: '六连包', //标签名称\\n      children: [\\n        {\\n          id: 'p_601', //标签属性名\\n          name: '可口可乐',\\n          children: [\\n            {\\n              id: 601, //标签属性id\\n              name: '可口可乐,雪碧', //标签属性名\\n            },\\n            {\\n              id: 605,\\n              name: '可口可乐芬达',\\n            },\\n          ],\\n        },\\n        {\\n          id: 'k_602',\\n          name: '大区',\\n          children: [\\n            {\\n              id: 602,\\n              name: '南区',\\n            },\\n          ],\\n        },\\n        {\\n          id: 9,\\n          name: '测试',\\n          children: [],\\n        },\\n      ],\\n    },\\n  ]\\n\\n  function findName(id, arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n      let item = arr[i];\\n      if (item.id == id) return item.name;\\n      if (Array.isArray(item.children)) {\\n        let str = findName(id, item.children);\\n        if(str) return str\\n      };\\n    }\\n  }\\n\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"广度搜索\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"广度搜索 (Breadth-First Search,BFS) 则是一种以广度为优先的搜索算法。它从起始节点开始，逐层地扫描图中的节点，先访问离起始节点最近的节点，然后才是离起始节点稍远的节点。BFS 通常使用队列数据结构来实现。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"以下是 BFS 的基本思想：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"将起始节点放入队列，并标记为已访问。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"从队列中取出一个节点，访问该节点并将其未访问的相邻节点加入队列。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"重复步骤 2 直到队列为空。\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"场景\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"最短路径问题：BFS 可以用于查找无权图或有权图中的最短路径，因为它按层级扩展，保证先访问离起始节点更近的节点。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"社交网络分析：BFS 可以用于在社交网络中查找两个人之间的最短关系链。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Web爬虫：BFS 可以用于构建 Web 爬虫，从一个网页开始按层级地爬取其他链接。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"静态分析：BFS 可以用于进行静态程序分析，检查代码中的依赖关系、引用关系等。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts:广度搜索\",\n        children: \"\\n  let test = [\\n    {\\n      id: 84, //标签id\\n      name: '六连包', //标签名称\\n      children: [\\n        {\\n          id: 'p_601', //标签属性名\\n          name: '可口可乐',\\n          children: [\\n            {\\n              id: 601, //标签属性id\\n              name: '可口可乐,雪碧', //标签属性名\\n            },\\n            {\\n              id: 605,\\n              name: '可口可乐芬达',\\n            },\\n          ],\\n        },\\n        {\\n          id: 'k_602',\\n          name: '大区',\\n          children: [\\n            {\\n              id: 602,\\n              name: '南区',\\n            },\\n          ],\\n        },\\n        {\\n          id: 9,\\n          name: '测试',\\n          children: [],\\n        },\\n      ],\\n    },\\n  ]\\n\\n  function findName(id,arr){\\n    let stack = [...arr];\\n    while(stack.length){\\n      let item = stack.shift();\\n      if(item.id==id) return item.name;\\n      if(Array.isArray(item.children)){\\n        stack.push(...item.children)\\n      }\\n    }\\n  }\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}