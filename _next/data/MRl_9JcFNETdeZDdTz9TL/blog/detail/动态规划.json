{"pageProps":{"metaData":{"title":"动态规划","description":"动态规划（Dynamic Programming）解决一些具有重叠子问题性质的问题。动态规划通常用于优化递归算法，通过将中间结果存储起来，避免重复计算同一个子问题","tags":["算法","动态规划"],"keywords":["算法","动态规划"],"id":"动态规划","create":1691979935551,"lastUpdate":1692153928598},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    h3: \"h3\",\n    pre: \"pre\",\n    code: \"code\",\n    blockquote: \"blockquote\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"动态规划\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"动态规划最核心的思想，就在于拆分子问题，记住过往，减少重复计算。\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"A ： \\\"1+1+1+1+1+1+1+1 =？\\\"\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"A ： \\\"上面等式的值是多少\\\"\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"B ： 计算 \\\"8\\\"\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"A : 在上面等式的左边写上 \\\"1+\\\" 呢？\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"A : \\\"此时等式的值为多少\\\"\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"B : 很快得出答案 \\\"9\\\"\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"A : \\\"你怎么这么快就知道答案了\\\"\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"A : \\\"只要在8的基础上加1就行了\\\"\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"A : \\\"所以你不用重新计算，因为你记住了第一个等式的值为8!动态规划算法也可以说是 '记住求过的解来节省时间'\\\"\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"斐波那契数列\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"指的是这样一个数列：这个数列从第3项开始，每一项都等于前两项之和。\\nF(0) = 0,F(1) = 1, F(n) = F(n - 1) + F(n - 2),\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js:动态规划-斐波那契数列\",\n        children: \"  function fibonacciDynamic(n) {\\n    if(n <= 1 ) return n;\\n    let dp = [];\\n    dp[0] = 0; dp[1] = 1;\\n\\n    for(let i = 2;i <= n; i++){\\n      dp[i] = dp[i-2]+dp[i-1]\\n    }\\n    return dp[n]\\n  }\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"青蛙跳阶问题\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"f(n) = f(n-1) + f(n-2)\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"对于一般情况的n，青蛙跳上第n级台阶有两种方式：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"青蛙\", _jsx(_components.code, {\n          children: \"从第n-1级台阶跳上来\"\n        }), \"：这种情况下，青蛙只需要从第n-1级台阶跳1级就能到达第n级台阶，所以这种方式的跳法数量为f(n-1)。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"青蛙\", _jsx(_components.code, {\n          children: \"从第n-2级台阶跳上来\"\n        }), \"：这种情况下，青蛙需要从第n-2级台阶跳2级才能到达第n级台阶，所以这种方式的跳法数量为f(n-2)。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"一只青蛙跳上n级的台阶有多少种跳法。\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"f(n) = 2*f(n-1)  |  2^(n-1)\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"下降路径最小和\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"给你一个 n x n 整数矩阵 grid ，请你返回 非零偏移下降路径 数字和的最小值。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"输入：grid = [[1,2,3],[4,5,6],[7,8,9]]\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"输出：13\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"解释：\\n所有非零偏移下降路径包括：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"[1,5,9], [1,5,7], [1,6,7], [1,6,8],\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"[2,4,8], [2,4,9], [2,6,7], [2,6,8],\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"[3,4,8], [3,4,9], [3,5,7], [3,5,9]\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"下降路径中数字和最小的是 [1,5,7] ，所以答案是 13 。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"解题思路:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"dp[i][j] 表示 第i行第j个元素的最小路径和\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"grid[i[j] 下降路径第i行第j个元素\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"dp[i][j] = dp[i-1][j] + grid[i[j]\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js:下降路径最小和\",\n        children: \"\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n * dp[i][j] 表示 第i行第j个元素的最小路径和\\n * dp[i][j] =min(dp[i-1][j])\\n */\\nfunction minFallingPathSum (grid) {\\n\\n    let dp = [[...grid[0]]]\\n    for (let i = 1; i < grid.length; i++) {\\n        dp[i] = []\\n        for (let j = 0; j < grid[i].length; j++) {\\n            let min;\\n            for (let d = 0; d < dp[i - 1].length; d++) {\\n                if (d != j) {\\n                    min = Math.min(min ?? dp[i - 1][d], dp[i - 1][d])\\n                }\\n            }\\n            dp[i][j] = min+grid[i][j]\\n        }\\n    }\\n    return Math.min(...dp.pop())\\n};\\n\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}