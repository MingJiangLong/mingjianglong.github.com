{"pageProps":{"metaData":{"title":"Koa 中间件","description":"主要是简单看一下源码","tags":["Koa"],"keywords":["Koa"],"id":"Koa-middlewarer","create":1682651966530,"lastUpdate":1692955490151},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    ol: \"ol\",\n    li: \"li\",\n    code: \"code\",\n    pre: \"pre\",\n    h3: \"h3\",\n    a: \"a\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Koa 中间件\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"搜索引擎一搜索koa中间件，大多都会谈及洋葱模型、next移交控制权。洋葱模型还能理解，可是next移交控制权听起来就很懵，所以抽空看了一下源码，看看怎么个移交法。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"首先看了一下简单的执行顺序\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"createServer:创建服务的时候,将callback的执行结果作为createServer的入参。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"callback: 返回一个新的函数， 通过createContext将res和resp封装成context对象作为第一参数,并将compose的执行结果作为第二参数\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"compose函数第一个参数是callback创建的context,第二个参数一般都叫next,其实它就是\", _jsx(_components.code, {\n          children: \"第i+1个中间件\"\n        }), \"，所以不要问为什么不执行next后面的中间件就不执行了\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js:koa/lib/application.js\",\n        children: \"class Application extends Emitter {\\n  use(fn) {\\n    this.middleware.push(fn);\\n    return this;\\n  }\\n  callback() {\\n    const fn = compose(this.middleware);\\n\\n    if (!this.listenerCount('error')) this.on('error', this.onerror);\\n\\n    const handleRequest = (req, res) => {\\n      const ctx = this.createContext(req, res);\\n      if (!this.ctxStorage) {\\n        return this.handleRequest(ctx, fn);\\n      }\\n      return this.ctxStorage.run(ctx, async() => {\\n        return await this.handleRequest(ctx, fn);\\n      });\\n    };\\n    return handleRequest;\\n  }\\n  listen(...args) {\\n    debug('listen');\\n    const server = http.createServer(this.callback());\\n    return server.listen(...args);\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"然后通过compose函数将各个中间件串联起来,compose函数会返回一个新的函数，入参为Context和Next，\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-JS:koa-compose/index.js\",\n        children: \"/**\\n * Compose `middleware` returning\\n * a fully valid middleware comprised\\n * of all those which are passed.\\n *\\n * @param {Array} middleware\\n * @return {Function}\\n * @api public\\n */\\nfunction compose (middleware) {\\n  return function (context, next) {\\n    // last called middleware #\\n    let index = -1\\n    return dispatch(0)\\n    function dispatch (i) {\\n      if (i <= index) return Promise.reject(new Error('next() called multiple times'))\\n      index = i\\n      let fn = middleware[i]\\n      if (i === middleware.length) fn = next\\n      if (!fn) return Promise.resolve()\\n      try {\\n        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));\\n      } catch (err) {\\n        return Promise.reject(err)\\n      }\\n    }\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"总结\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"中间件的next就是中间件(通过compose将中间件串联起来的)就是按照注册顺序，当前中间的下一个中间件,所有的中间件的执行顺序可以参照asyncawait代码执行顺序。所以你要想你下一个中间件正常执行，你记得要调用下一个中间件(也就是next)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://github.com/koajs/koa/wiki#middleware\",\n        children: \"更多中间件\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}