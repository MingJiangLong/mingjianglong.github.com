{"pageProps":{"mdxList":[{"metaData":{"title":"友宝项目架构","description":"简单学习一下友宝的前端项目架构","tags":["架构"],"keywords":["架构"],"id":"友宝项目架构","create":1682416219038,"lastUpdate":1682505756719},"content":"# 友宝项目架构\n简单学习一下友宝的前端项目架构\n\n友宝的前端项目的整体架构底层技术栈选用的是PHP+React，使用PHP做为外壳，内部重定向web静态资源。web资源请求首先经过的是PHP接口,经过一系列的中间件处理(比如鉴权之类...)，最后将页面展示需要的数据通过window对象注入静态页面，然后再将静态页面返回给浏览器渲染。\n\n感觉整体架构的思路有点类似于服务端渲染的思想，每次页面请求都是经过的服务端接口，服务端再去决定返回什么资源，实际返回的是一个已经有数据的静态页面，但是没有经过渲染，只是有页面数据，还是需要客户端渲染。\n\n优点\n\n  * 前端开发不需要网络服务模块\n  * 服务端感知度低\n  * 将静态数据注入的方式，减小的客户端的压力\n  * 方便页面重定向，定制化页面(可以通过外壳统一做特定活动之类的)\n\n\n\n缺点\n\n  * 前端依赖的数据都是注入在window对象，如果window对象被后续修改将获取不到内容\n  * 应用场景少，只能应用于不经常变化的数据。\n  * 前端开发BUG定位调试变得困难，开发环境虽然可mock数据，但是如果需要针对特定bug，修复bug发布之后才能看到修复结果。\n  * 前后端耦合\n"},{"metaData":{"title":"vue3 学习","description":"vue3搭建一个小项目，项目用于公司零售柜价格设置。项目选型之所以选vue3，主要是用了我之前很久远的一个Vue2脚手架,写起来有点膈手，外加上vue3在国内火，想着是小项目就随便我折腾了。","tags":["Vue3"],"keywords":["Vue3"],"id":"vite-vue3","create":1682416219032,"lastUpdate":1682505756718},"content":"# vue3 学习\n\nvue3搭建一个小项目，项目用于公司零售柜价格设置。项目选型之所以选vue3，主要是用了我之前很久远的一个Vue2脚手架,写起来有点膈手，外加上vue3在国内火，想着是小项目就随便我折腾了\n\n首先去搜索引擎找了一个脚手架vite,一路enter就好了。对了vue3的全局状态管理推荐用**pinia**了，狗头保命...之前我都没听说这个玩意\n> npm create vite@latest\n\n创建完了，跑起项目就 可以看到\"Hello World\"了。\n\n我这边是一个H5项目，需要做屏幕适配。所以 `postcss-pxtorem`+ `autoprefixer`+`amfe-flexible` install到项目里，然后按照demo配置一下。最主要的就是`rootValue`这个属性，设计稿除以10\n\n```JS:.postcssrc.cjs\n module.exports = {\n  plugins: {\n    autoprefixer: {\n      Browserslist: [\"Android >= 4.0\", \"iOS >= 7\"],\n    },\n    \"postcss-pxtorem\": {\n      rootValue: 37.5, //结果为：设计稿元素尺寸/37.5，比如元素宽375px,最终页面会换算成 10rem\n      propList: [\"*\"],\n      // 黑名单\n      // selectorBlackList: [\n      //   'van-'\n      // ],\n    },\n  },\n};\n```\n\nUI整的是`Vant`,为什么用这个，我也很纳闷，设计又不按照这个UI组件设计，领导又让用这个库，总之项目Ui自定义高就别用什么组件了,自己费尽整一套就好，\n\n最后整个`axios`和css预编译,框框就差不多了。\n\n接着就是看一下Vue APi 配方和以前大差不差。以前很讨厌vue整一个大对象，把所有的东西都塞里面，看起来很廉价。现在这个组合式的感觉像是那么回事了。\n\n* defineProps\n* defineEmit\n* defineProps\n* watch\n* watEffect\n* ref\n* reactive\n* computed\n* ...\n\n对了我的编辑器是vscode,如果要用vue3 就不要用`vuter`了提示支持不友好，新的插件`volar`，如果vscode下载不下来就需要去官网下载，把包里package.json vscode版本改的和自己编辑器的版本一眼,再手动安装,详细教程搜索引擎自取。\n\n中间碰到一个很恶心的事情,Vant的组件有很多自定义css样式,想全局修改。index.html修改失败，按照官网的:root:root也不行，最后就整了一个js文件在入口统一修改...囧\n```JS\n  export function updateVantCSSVar() {\n    let cssVar = [\n      ['--van-tabs-bottom-bar-color', '#FF7500'],\n      ['--van-tabs-nav-background', 'transparent'],\n      ['--van-field-label-width', '5.5em'],\n    ]\n\n    cssVar.forEach(item => {\n      document.documentElement.style.setProperty(item[0], item[1])\n    })\n  }\n```\n\n顺路又学了一下less定义全局变量\n```JS:VITE.CONFIG.JS\n// VITE.CONFIG.JS\nexport default defineConfig(({ mode }) => {\n  return {\n    css: {\n      preprocessorOptions: {\n        less: {\n          modifyVars: {\n            // 这个用来定义全局变量的\n            hack: `true; @import \"${path.resolve(__dirname, \"./src/assets/css/base.less\")}\"`\n            // '--van-field-label-width': '6.3em'\n          },\n          globalVars: {\n\n          },\n        }\n      }\n    }\n  }\n})\n\n  //base.less\n  @test-color: red;\n  @goods-img: 60px;\n  @yellow: #FF7500;\n\n```\n\n最后打包，默认的是`/`,建议配置 `base`为`./`,不然如果项目不是在根目录就找不到静态资源了。\n\n### 碰到的糟心问题\n\n  - 白屏\n\n    如果任何报错都没有,建议检查router的模式是否用的是`history`\n  * ts中引入Vue文件报错\n\n    ```ts:sfc.d.ts\n      //增加一个 sfc.d.ts\n      declare module '*.vue' {\n        import { ComponentOptions } from 'vue'\n        const componentOptions: ComponentOptions\n        export default componentOptions\n      }\n    ```\n  * vconsole引入\n    ```JS:main.ts\n      if (import.meta.env.MODE !== 'prod') {\n\n        // 网上的教程大多是下面这种引入，实际上会报错\n        app.use(new Vconsole())\n\n        // 以下引入可以正常使用\n        new Vconsole()\n\n        // 这种也可以\n        app.use(()=>new Vconsole())\n      }\n    ```\n  * 部分浏览器黑屏兼容问题,版本较低的浏览器不支持ES6的语法和新API，而Babel默认只转换新的JavaScript句法，不转换新的API，比如Proxy、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法都不会转码。\n    > yarn add @vitejs/plugin-legacy terser\n    ```ts:vite.config.ts\n      import legacy from '@vitejs/plugin-legacy'\n      export default defineConfig(({ mode }) => {\n        return {\n          plugins: [\n            legacy({\n              targets: ['defaults', 'ie >= 11', 'chrome 52'],  //需要兼容的目标列表，可以设置多个\n              additionalLegacyPolyfills: ['regenerator-runtime/runtime'],\n              renderLegacyChunks: true,\n              polyfills: [\n                'es.symbol',\n                'es.array.filter',\n                'es.promise',\n                'es.promise.finally',\n                'es/map',\n                'es/set',\n                'es.array.for-each',\n                'es.object.define-properties',\n                'es.object.define-property',\n                'es.object.get-own-property-descriptor',\n                'es.object.get-own-property-descriptors',\n                'es.object.keys',\n                'es.object.to-string',\n                'web.dom-collections.for-each',\n                'esnext.global-this',\n                'esnext.string.match-all'\n              ]\n            })\n          ],\n          resolve: {\n            alias: {\n              '@': path.resolve(__dirname, 'src'),\n            },\n          },\n          server: { },\n          css: { }\n        }\n      })\n    ```\n  * xing2233333\n\n\n  \n  \n\n\n\n\n\n"},{"metaData":{"title":"凸包-地图围栏","description":"公司零售货柜机在地图上的点需要围栏圈起来，以便显示大致范围","tags":["算法"],"keywords":["算法"],"id":"凸包-地图围栏-二分算法","create":1682416219035,"lastUpdate":1682505756718},"content":"# 凸包算法-地图围栏\n\n公司零售货柜机在地图上的点需要围栏圈起来，以便显示大致范围\n\n```js\n\n/**\n *      p2\n *  p1<\n *      p3\n * 叉积判断 p1p2 p1p3\n * | p2.x-p1.x | p2.y-p1.y |\n * | p3.x-p1.x | p3.y-p1.y |\n * @param {{x:number,y:number}} p1 \n * @param {{x:number,y:number}} p2 \n * @param {{x:number,y:number}} p3 \n */\nfunction crossProduct(p1, p2, p3) {\n  return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);\n}\n\n/**\n * \n * @param {{x:number,y:number}[]} points \n */\nfunction getConvexHull(points) {\n\n  if (points.length <= 1) { return points; }\n\n  //按照x坐标排序 \n  points.sort((a, b) => a.x - b.x || a.y - b.y);\n  let lowerHull = [];\n  for (let i = 0; i < points.length; i++) {\n    //构建下凸包\n\n    // 遍历凸包数据集判断当前点Pi是否在 H(n-2)H(n-1)的内侧(叉积<0)，如果在内侧就移除H(n-1) \n    while (\n      lowerHull.length >= 2 && \n      crossProduct(lowerHull[lowerHull.length - 2], lowerHull[lowerHull.length - 1], points[i]) <= 0\n    ) {\n      lowerHull.pop();\n    }\n    lowerHull.push(points[i]);\n  }\n  let upperHull = [];\n  for (let i = points.length - 1; i >= 0; i--) {\n    //构建上凸包\n    while (\n      upperHull.length >= 2 && \n      crossProduct(upperHull[upperHull.length - 2], upperHull[upperHull.length - 1], points[i]) <= 0) {\n      upperHull.pop();\n    }\n    upperHull.push(points[i]);\n  }\n  //合并上下凸包 \n  upperHull.pop();\n  lowerHull.pop();\n  return lowerHull.concat(upperHull);\n}\n```\n"},{"metaData":{"title":"Vite打包","description":"Vite 打包配置学习","tags":["Vite"],"keywords":["Vite"],"id":"vite-config","create":1682495747004,"lastUpdate":1682505756717},"content":"# Vite打包\n\nvite.config.js配置文件选项注释说明\n\n```ts:vite.config.ts\nimport { defineConfig } from \"vite\";\nimport vue from \"@vitejs/plugin-vue\";\nimport path from \"path\";\nexport default defineConfig({\n\n  //项目根目录\n  root: process.cwd(),\n  \n  //项目部署的基础路径\n  base: \"/\",\n  \n  //环境配置 'development'|'production'\n  mode: \"development\",\n  \n  //全局常量替换 Record<string, string>\n  define: {\n    \"\": \"\",\n    user: \"users\",\n  },\n  \n  //插件\n  plugins: [vue()],\n  \n  //静态资源服务的文件夹\n  publicDir: \"public\",\n  \n  //存储缓存文件的目录\n  cacheDir: \"node_modules/.vite\",\n  \n  resolve: {\n    //别名\n    alias: {\n      \"@\": path.resolve(__dirname, \"/src\"),\n    },\n    dedupe: [],\n\n    //解决程序包中package.json配置中的exports 字段\n    conditions: [],\n    \n    //解析package.json中字段的优先级\n    mainFields: [\"module\", \"jsnext:main\", \"jsnext\"],\n    \n    //导入时想要省略的扩展名列表\n    extensions: [\".mjs\", \".js\", \".ts\", \".jsx\", \".tsx\", \".json\"],\n    \n    //使Vite通过原始文件路径而不是真正的文件路径确定文件身份\n    preserveSymlinks: false,\n  },\n  css: {\n    \n    //配置 CSS modules 的行为。选项将被传递给 postcss-modules。\n    modules: {},\n    \n    // PostCSS 配置（格式同 postcss.config.js）\n    // postcss-load-config 的插件配置\n    postcss: {},\n    \n    //指定传递给 CSS 预处理器的选项\n    preprocessorOptions: {\n      scss: {\n        additionalData: `$injectedColor: orange;`,\n      },\n    },\n    \n    //开发过程中是否启sourcemap\n    devSourcemap: false,\n  },\n  json: {\n   \n    //是否支持从 .json 文件中进行按名导入\n    namedExports: true,\n   \n    //若设置为 true，导入的 JSON 会被转换为 export default JSON.parse(\"...\") 会比转译成对象字面量性能更好，\n    stringify: false,\n  },\n  \n  //继承自 esbuild 转换选项。最常见的用例是自定义 JSX\n  esbuild: {\n    jsxFactory: \"h\",\n    jsxFragment: \"Fragment\",\n    jsxInject: `import React from 'react'`,\n  },\n  \n  //静态资源处理  字符串|正则表达式\n  assetsInclude: [\"**/*.gltf\"],\n  \n  //调整控制台输出的级别 'info' | 'warn' | 'error' | 'silent'\n  logLevel: \"info\",\n  \n  //设为 false 可以避免 Vite 清屏而错过在终端中打印某些关键信息\n  clearScreen: true,\n  \n  //加载 .env 文件的目录\n  envDir: \"\",\n  \n  //envPrefix开头的环境变量会通过import.meta.env暴露客户端源码\n  envPrefix: \"VITE_\",\n  \n  //设置'spa' | 'mpa' | 'custom'应用操作\n  appType: \"spa\",\n  \n  //服务\n  server: {\n  \n    //服务器主机名\n    host: \"localhost\",\n  \n    //端口号\n    port: \"5173\",\n  \n    //设为 true 时若端口已被占用则会直接退出，而不是尝试下一个可用端口\n    strictPort: true,\n  \n    //https.createServer()配置项\n    https: \"\",\n  \n    //服务器启动时自动在浏览器中打开应用程序。\n    open: \"/docs/index.html\",\n  \n    //自定义代理规则\n    proxy: {\n  \n      // 字符串简写写法\n      \"/foo\": \"http://localhost:4567\",\n  \n      // 选项写法\n      \"/api\": {\n        target: \"http://jsonplaceholder.typicode.com\",\n        changeOrigin: true,\n        rewrite: (path) => path.replace(/^\\/api/, \"\"),\n      },\n  \n      // 正则表达式写法\n      \"^/fallback/.*\": {\n        target: \"http://jsonplaceholder.typicode.com\",\n        changeOrigin: true,\n        rewrite: (path) => path.replace(/^\\/fallback/, \"\"),\n      },\n  \n      // 使用 proxy 实例\n      \"/api\": {\n        target: \"http://jsonplaceholder.typicode.com\",\n        changeOrigin: true,\n        configure: (proxy, options) => {\n          // proxy 是 'http-proxy' 的实例\n        },\n      },\n  \n      // Proxying websockets or socket.io\n  \n      \"/socket.io\": {\n        target: \"ws://localhost:3000\",\n        ws: true,\n      },\n    },\n  \n    //开发服务器配置 CORS\n    cors: {},\n  \n    //指定服务器响应的 header ,类型OutgoingHttpHeaders\n    header: {},\n  \n    //禁用或配置 HMR 连接\n    hmr: {},\n  \n    //传递给 chokidar 的文件系统监视器选项\n    watch: {},\n  \n    //中间件模式创建 Vite 服务器,'ssr' | 'html'\n    middlewareMode: \"ssr\",\n  \n    //HTTP请求中预留此文件夹，用于代理 Vite 作为子文件夹时使用。\n    base: \"\",\n  \n    fs: {\n      //限制为工作区 root 路径以外的文件的访问\n      strict: true,\n      //限制哪些文件可以通过 /@fs/ 路径提供服务\n      allow: [\n        // 搜索工作区的根目录\n        searchForWorkspaceRoot(process.cwd()),\n        // 自定义规则\n        \"/path/to/custom/allow\",\n      ],\n  \n      //限制Vite开发服务器提供敏感文件的黑名单\n      deny: [\".env\", \".env.*\", \"*.{pem,crt}\"],\n    },\n  \n    //定义开发调试阶段生成资产的url\n    origin: \"http://127.0.0.1:8080\",\n  },\n  \n  //构建\n  build: {\n  \n    //浏览器兼容性  \"esnext\"|\"modules\"\n    target: \"modules\",\n  \n    //否自动注入 module preload 的 polyfill\n    polyfillModulePreload: true,\n  \n    //输出路径\n    outDir: \"dist\",\n  \n    //生成静态资源的存放路径\n    assetsDir: \"assets\",\n  \n    //小于此阈值的导入或引用资源将内联为 base64 编码，以避免额外的 http 请求。设置为 0 可以完全禁用此项\n    assetsInlineLimit: 4096,\n  \n    //启用/禁用 CSS 代码拆分\n    cssCodeSplit: true,\n  \n    //不同的浏览器target设置CSS的压缩\n    cssTarget: \"\",\n  \n    //构建后是否生成 source map 文件\n    //boolean | 'inline' | 'hidden'\n    sourcemap: false,\n    \n    //自定义底层的 Rollup 打包配置\n    rollupOptions: {\n    \n      //要打包的文件路径\n      input: \"src/main.js\",\n    \n      //文件输出位置\n      output: {\n    \n        //打包生产文件路径\n        file: \"dist/index.js\",\n    \n        //打包输出格式\n        // \"amd\", \"cjs\", \"system\", \"es\", \"iife\" or \"umd\n        format: \"cjs\",\n\n        //包的全部变量名称\n        name: \"bundleName\",\n\n        //声明全局变量\n        globals: {\n          jquery: \"$\",\n        },\n      },\n\n      //插件\n      plugins: [],\n\n      //不需打包的文件\n      external: [\"lodash\"],\n    },\n\n    //@rollup/plugin-commonjs 插件的选项\n    commonjsOptions: {},\n\n    //@rollup/plugin-dynamic-import-vars 选项\n    dynamicImportVarsOptions: {},\n\n    //构建的库\n    lib: {\n      entry: path.resolve(__dirname, \"lib/main.js\"),\n\n      //暴露的全局变量\n      name: \"mylib\",\n\n      //'es' | 'cjs' | 'umd' | 'iife'\n      formats: \"es\",\n\n      //输出的包文件名\n      fileName: \"my-lib\",\n    },\n\n    //当设置为 true，构建后将会生成 manifest.json 文件\n    manifest: false,\n\n    //当设置为 true，构建后将会生成SSR的manifest.json 文件\n    ssrManifest: false,\n\n    //生成面向 SSR 的构建\n    ssr: \"undefined\",\n\n    //设置为 false 可以禁用最小化混淆，\n    //boolean | 'terser' | 'esbuild'\n    minify: \"esbuild\",\n\n    //传递给 Terser 的更多 minify 选项。\n    terserOptions: {},\n\n    //设置为 false 来禁用将构建后的文件写入磁盘\n    write: true,\n\n    //默认情况下，若 outDir 在 root 目录下，则 Vite 会在构建时清空该目录。\n    emptyOutDir: true,\n\n    //启用/禁用 gzip 压缩大小报告\n    reportCompressedSize: true,\n\n    //触发警告的 chunk 大小（以 kbs 为单位）\n    chunkSizeWarningLimit: 500,\n\n    //设置为 {} 则会启用 rollup 的监听器\n    watch: null,\n  },\n\n  //开发服务器\n  preview: {\n\n    //开发服务器主机名\n    host: \"localhost\",\n\n    //开发服务器端口号\n    port: \"5173\",\n\n    //设为 true 时若端口已被占用则会直接退出，而不是尝试下一个可用端口\n    strictPort: true,\n\n    //https.createServer()配置项\n    https: \"\",\n\n    //服务器启动时自动在浏览器中打开应用程序。\n    open: \"/docs/index.html\",\n\n    //开发服务器，自定义代理规则\n    proxy: {\n      // 字符串简写写法\n      \"/foo\": \"http://localhost:4567\",\n      // 选项写法\n      \"/api\": {\n        target: \"http://jsonplaceholder.typicode.com\",\n        changeOrigin: true,\n        rewrite: (path) => path.replace(/^\\/api/, \"\"),\n      },\n      // 正则表达式写法\n      \"^/fallback/.*\": {\n        target: \"http://jsonplaceholder.typicode.com\",\n        changeOrigin: true,\n        rewrite: (path) => path.replace(/^\\/fallback/, \"\"),\n      },\n      // 使用 proxy 实例\n      \"/api\": {\n        target: \"http://jsonplaceholder.typicode.com\",\n        changeOrigin: true,\n        configure: (proxy, options) => {\n          // proxy 是 'http-proxy' 的实例\n        },\n      },\n      // Proxying websockets or socket.io\n      \"/socket.io\": {\n        target: \"ws://localhost:3000\",\n        ws: true,\n      },\n    },\n    //开发服务器配置 CORS\n    cors: {},\n  },\n\n  //依赖优化选项\n  optimizeDeps: {\n\n    //检测需要预构建的依赖项\n    entries: [],\n\n    //预构建中强制排除的依赖项\n    exclude: [\"jquery\"],\n\n    //默认情况下，不在 node_modules 中的，链接的包不会被预构建。使用此选项可强制预构建链接的包。\n    include: [],\n\n    //部署扫描和优化过程中传递给EsBuild\n    esbuildOptions: {},\n\n    //设置为 true 可以强制依赖预构建，而忽略之前已经缓存过的、已经优化过的依赖\n    force: true,\n  },\n\n  //SSR 选项\n  ssr: {\n\n    //列出的是要为 SSR 强制外部化的依赖\n    external: [],\n\n    //列出的是防止被 SSR 外部化依赖项。\n    noExternal: [],\n\n    //SSR 服务器的构建目标\n    target: \"node\",\n\n    //SSR 服务器的构建语法格式 'esm' | 'cjs'\n    format: \"esm\",\n  },\n  worker: {\n\n    //worker 打包时的输出类型 'es' | 'iife'\n    format: \"iife\",\n\n    // worker 打包的 Vite 插件\n    plugins: [],\n\n    //打包 worker 的 Rollup 配置项\n    rollupOptions: {},\n  },\n});\n```\n"},{"metaData":{"title":"ReactNative Put方式上传文件","description":"ReactNative Put方式上传文件","tags":["RN","PUT"],"keywords":["RN"],"id":"rn-putfile","create":1682419800709,"lastUpdate":1682505756716},"content":"# React Native Put方式文件上传\n\n之前项目一直采用的后端上传，RN将文件使用FormData的形式传递给后端，为了解决文件过大的原因，采用RN使用PUT直接将文件上传至图片服务器;\n\n```ts\n/**\n * 图片上传请求工具\n * @param beforeUpload \n * @param afterUpload \n * @returns \n */\nexport default async function UploadFileToOSS(\n    fileData: FileInfo,\n    beforeUpload: () => Promise<{ uploadUrl: string, key: string }>,\n    afterUpload: (key: string) => Promise<string>) {\n\n    // 1. 获取上传地址和key\n    let { uploadUrl, key } = await beforeUpload();\n\n    // fetch 为React Native 系统api\n    await fetch(uploadUrl, {\n        method: 'PUT',\n        body: {\n            uri: fileData.uri\n        },\n        headers: {\n            'Content-Type': fileData.type\n        }\n    })\n\n    // 3. 使用key换取上传地址\n    if (typeof afterUpload === 'function') {\n        return await afterUpload(key)\n    }\n\n    return key;\n}\n\ntype FileInfo = {\n    name: string\n    uri: string\n    type: string\n    base64: string\n}\n```\n"},{"metaData":{"title":"博客测试","description":"NextJS打包相关问题以及解决办法","tags":["NextJS"],"keywords":["NextJS"],"id":"test","create":1682416219030,"lastUpdate":1682505756716},"content":"# NextJS打包相关问题\n\nNextJS打包相关问题以及解决办法，更多参见[Next文档](https://www.nextjs.cn/)\n\n>Eslint、Ts类型校验关闭\n```js:next.config.js\n  const nextConfig = {\n  \n    eslint:{\n      ignoreDuringBuilds:true\n    },\n      typescript: {\n      // !! WARN !!\n      // Dangerously allow production builds to successfully complete even if\n      // your project has type errors.\n      // !! WARN !!\n      ignoreBuildErrors: true,\n    }\n  }\n```\n\n\n\n> Image Optimization using Next.js' default loader is not compatible with `next export`.\n\n```JS\nmodule.exports = {\n  // https://github.com/vercel/next.js/issues/21079\n  // Remove this workaround whenever the issue is fixed\n  images: {\n    loader: 'imgix',\n    path: '',\n  },\n}\n```\n\n> 图片加载不出来\n"},{"metaData":{"title":"NextJS打包","description":"NextJS打包配置对应字段了解，进行简单的打包测试","tags":["NextJS"],"keywords":["NextJS"],"id":"next打包配置学习","create":1682416219028,"lastUpdate":1682505756715},"content":"NextJS打包配置对应字段了解，进行简单的打包测试\n> `assetPrefix` 静态资源前缀\n```js\n  const nextConfig = {\n    assetPrefix:'/前缀'\n  }\n```\n\n> `Redirects` 将source原路径重定向到destination新路径，访问的是destination路径;\n```JS\n// 最终访问的是/blog路径,浏览器显示的也是blog路径\nconst nextConfig = {\n  redirects() {\n    return [\n      {\n        source: \"/\",\n        destination: \"/blog\",\n        permanent: true\n      }\n    ]\n  },\n}\n```\n> `Rewrites`  将原路径充当代理以此来屏蔽目标路径。浏览器显示的是destination路径，实际访问的是source路径；功能类似于**userRouter.push(path,as)**中 参数**as**的功能;\n```JS\n// 浏览器显示的是\"/blog\"，实际访问的是\"/\"路径\nconst nextConfig = {\n  async rewrites() {\n    return [\n      {\n        source: '/',\n        destination: '/blog'\n      }\n    ]\n  },\n}\n```\n"},{"metaData":{"title":"NextJS","description":"NextJS打包相关问题以及解决办法","tags":["NextJS"],"keywords":["NextJS"],"id":"next打包相关问题","create":1682416219026,"lastUpdate":1682505756714},"content":"# NextJS打包相关问题\n\nNextJS打包相关问题以及解决办法，更多参见[Next文档](https://www.nextjs.cn/)\n\n>Eslint、Ts类型校验关闭\n```js:next.config.js\n  const nextConfig = {\n  \n    eslint:{\n      ignoreDuringBuilds:true\n    },\n      typescript: {\n      // !! WARN !!\n      // Dangerously allow production builds to successfully complete even if\n      // your project has type errors.\n      // !! WARN !!\n      ignoreBuildErrors: true,\n    }\n  }\n```\n\n\n\n> Image Optimization using Next.js' default loader is not compatible with `next export`.\n\n```JS\nmodule.exports = {\n  // https://github.com/vercel/next.js/issues/21079\n  // Remove this workaround whenever the issue is fixed\n  images: {\n    loader: 'imgix',\n    path: '',\n  },\n}\n```\n\n> 图片加载不出来\n"},{"metaData":{"title":"Git-Workflow","description":"解决开发之后需要做的事，打包上线","tags":["Git"],"keywords":["Git"],"id":"gitworkflow","create":1682416219022,"lastUpdate":1682505756713},"content":"# Git Workflow\n解决开发之后需要做的事，打包上线\n\n在项目根目录添加 .github/workflows/integrate.yml\n\n真的是气死个人，这段yml是cv来的，别人就能正常运行，但是我拿过来就报错。首先就是报错NextJS包里有`appKey??**`,\n一开始我看到这个还以为是这个包里有ES6语法，编译出问题。就用babel.config配置去编译node_modules，我也不知道编译对了没有总之没有生效，想来是错了\n后来我用windows的node环境试了一下这个语法发现node是可以用的，于是我猜测会不会是workflows的node版本过低，升级了版本就好了。。。。\n\n```yml:.github/workflows/integrate.yml\nname: Build and Deploy\non: \n  push:\n    branches:\n      - blog-next\njobs:\n  build-and-deploy:\n    # 虚拟机环境 ubuntu-latest，ubuntu-18.04或ubuntu-16.04\n    # windows-latest，windows-2019或windows-2016\n    # macOS-latest或macOS-10.14\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2.3.1\n        with:\n          persist-credentials: false\n\n      - name: Cache\n        uses: actions/cache@v2\n        with:\n          path: ${{ github.workspace }}/.next/cache\n          key: ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}\n\n      - name: Install and Build\n        uses: actions/setup-node@v3\n        with:\n          node-version: 16\n      - run: npm install\n      - run: npm run transMD\n      - run: npm run build\n      - run: npm run export\n        env:\n            CI: true\n      - run: touch out/.nojekyll\n\n      - name: Deploy\n        uses: JamesIves/github-pages-deploy-action@3.7.1\n        with:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          BRANCH: lj-pages\n          FOLDER: out # The folder the action should deploy.\n          CLEAN: true # Automatically remove deleted files from the deploy branch\n```\n"},{"metaData":{"title":"Git","description":"git常用命令记录，主要是容易忘","tags":["Git"],"keywords":["Git"],"id":"git使用","create":1682416219024,"lastUpdate":1682505756713},"content":"# Git常用操作\n\ngit常用命令记录，主要是容易忘\n\n\n>`git pull -f origin master:master`\n  如果远程分支和本地分支代码相差太大，可以考虑用远程的覆盖本地代码\n"},{"metaData":{"title":"The request client is not a secure context and the resource is in more-private address space 'private'","description":"浏览器安全策略","tags":["安全","浏览器"],"keywords":["安全","浏览器"],"id":"CORS-policy","create":1682416219017,"lastUpdate":1682505756710},"content":"# CORS policy\n\nAccess to XMLHttpRequest at '\\*\\*' from origin '\\*\\*' has been blocked by CORS policy: The request client is not a secure context and the resource is in more-private address space \\`private`.\n\n![The request client is not a secure context and the resource is in more-private address space 'private'](/md-images/pna.jpg)\n\n\n## 原因\n  与第三方相关。访问私有IP地址时，Chrome 会请求安全连接。Chrome 将弃用从非安全网站访问专用网络端点访问（以前称为 CORS-RFC1918）规范的一部分\n\n\n- [What is Private Network Access](https://developer.chrome.com/blog/private-network-access-update/#what-is-private-network-access)\n- [Chrome's plans to enable CORS-RFC1918](https://developer.chrome.com/articles/cors-rfc1918-feedback/#chrome's-plans-to-enable-cors-rfc1918)\n\n## 解决方法\n\n  前端接口和后端接口统一都用`https`\n\n\n### 什么是IP\n\n  在网络中，每台计算机都有一个唯一的地址，方便别人找到它，这个地址称为IP地址。IP地址是一个网络编码，用来确定网络中的一个节点，是由`32位的二进制`组成\n\n### IP地址的组成 \n\n  IP地址由`网络部分`和`主机部分`两部分组成\n  网络部分标示不同的网络\n  主机部分标示在一个网络中特定的主机\n\n### IP分类\n\n  IP地址的网络部分是由internet地址分配机构来统一分配的，这样可以保证IP的唯一性\n  IP地址中全为1的IP即255.255.255.255 它标示限制广播地址，如果将其作为数据包的目标地址可以理解为发送到所有网络的所有主机\n  IP地址全为0的IP即0.0.0.0 表示启动时的IP地址 含义尚未未分配的IP地址\n  127是用来进行本机测试的，除了127.255.255.255外，其他的`127开头的地址都代表本机`\n\n### 公有IP和私有IP\n私有IP\n  - A类 1-126 每个网络中可以有2的24次方-2台的主机\n  - B类 128-191 最大的主机数为 2的16次方减2\n  - C类 192-223 最大的主机数量是2的8次方减2\n\n其他范围的IP均为公有IP地址\n\n### 区别\n  公有IP地址：\n\n  组建一个企业级网络，需要去向“电信运营商ISP”申请一个接入Internet的宽带，同时ISP还会给我们分配一个或多个IP地址，这些IP地址可以供我们企业内部上网，这些ISP分配给我们的IP，就是公有IP。\n\n  公有地址（Public address，也可称为公网地址）由Internet NIC（Internet Network Information Center因特网信息中心）负责。这些IP地址分配给注册并向Internet NIC提出申请的组织机构。通过它直接访问因特网，它是广域网范畴内的。\n\n  私有IP地址：\n\n  我们企业或家庭内部组建局域网用的IP，一般都会用私有IP。\n  私有地址（Private address，也可称为专网地址）属于非注册地址，专门为组织机构内部使用，它是局域网范畴内的，私有IP禁止出现在Internet中，在ISP连接用户的地方，将来自于私有IP的流量全部都会阻止并丢掉。\n  《如果在企业内部的电脑要访问Internet，则需要在企业边界上用“NAT技术”将私网IP转成公网IP才能正常的上网。》\n"}]},"__N_SSG":true}