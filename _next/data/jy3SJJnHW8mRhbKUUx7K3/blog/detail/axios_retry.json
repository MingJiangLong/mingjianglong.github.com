{"pageProps":{"metaData":{"title":"Axios重试","description":"基于Axios封装接口重试","tags":["Axios"],"keywords":["H5","Vue","Android"],"id":"axios_retry","create":1686903407603,"lastUpdate":1691569947187},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Axios重试封装\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"import Axios from 'axios'\\nimport { getToken } from '@/util/token'\\n\\nconst http = Axios.create({\\n  timeout: 1000 * 15,\\n  timeoutErrorMessage: '服务器繁忙,稍候重试',\\n})\\n\\nhttp.interceptors.response.use(async (data) => {\\n  if (data?.data?.code != 200) throw new Error(data?.data?.message ?? '服务器异常')\\n  return data.data\\n}, async (error) => {\\n  let config = error?.config;\\n  // 防止retry被intercept.request中配置覆盖，造成死循环\\n  let retry = error?.config?.headers?.retry;\\n  let __retry__ = error?.config?.headers?.__retry__;\\n\\n  if(!!retry && __retry__ == undefined){\\n    error?.config?.headers?.__retry__ = --retry\\n    return http(error.config)\\n  }\\n\\n  if(__retry__){\\n    error?.config?.headers?.__retry__ = --__retry__\\n    return http(error.config)\\n  }\\n  return Promise.reject(error)\\n})\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}