{"pageProps":{"metaData":{"title":"React Provider使用","description":"React Provider使用","tags":["React","Provider"],"keywords":["React","Provider"],"id":"ReactProvider","create":1705631674804,"lastUpdate":1705633338065},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    h3: \"h3\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"React Provider使用\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"###总结\\nProvider 可以用作拆分代码，不适用于公共组件使用\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"背景\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Provider在多层级传递参数有很好的应用,通常我们上下级组件传递参数都会使用props进行参数传递。但是一旦组件嵌套层级过多，从最外层组件向最内层组件传递参数就需要经过组件层层传递\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx:demo.tsx\",\n        children: \"  // 如下代码向内部Component3传递一个topName就需要进过层层传递才能到达最内层组件,\\n  function Component1(){\\n    return (\\n      <>\\n        <Component2 topName=\\\"Component1\\\">\\n          <Component3></Component3>\\n        </Component2>\\n      </>\\n    )\\n  }\\n\\n  function Component2({topName}){\\n    return (\\n      <>\\n          <Component3 topName/>\\n      </>\\n    )\\n  }\\n  function Component3({topName}){\\n    return <div>{topName}</div>\\n  }\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Provider\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"provider则可以避免这种繁琐的代码,可以topName的传递可以完全绕过Component2\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx:demo2.tsx\",\n        children: \"  const CONTEXT = createContext({\\n    topName:''\\n  })\\n  function Component1(){\\n    return (\\n      <CONTEXT.Provider value={{\\n        topName:\\\"Component1\\\"\\n      }}>\\n        <Component2>\\n          <Component3></Component3>\\n        </Component2>\\n      </CONTEXT.Provider>\\n    )\\n  }\\n\\n  function Component2(){\\n    return (\\n      <>\\n          <Component3/>\\n      </>\\n    )\\n  }\\n\\n  function Component3(){\\n    cont TOP_CONTEXT=useContext(CONTEXT)\\n    return <div>{TOP_CONTEXT.topName}</div>\\n  }\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"###问题\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这样写虽然可以避免一定量的重复代码，但是也会造成性能问题，最重要的还会造成组件的不可复用性。\\n如果Component3只是拆分的代码这样写没有多大的问题，如果Component3是一个公共组件，其他页面使用该组件就会导致Component3获取不到CONTEXT。当然也可以用if判断,但是这样就会导致组件的可复用性降低。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}