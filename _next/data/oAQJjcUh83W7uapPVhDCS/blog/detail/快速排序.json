{"pageProps":{"metaData":{"title":"快速排序","description":"快速排序","tags":["算法","排序"],"keywords":["算法","排序"],"id":"快速排序","create":1691743637451,"lastUpdate":1692954726913},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    blockquote: \"blockquote\",\n    h3: \"h3\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"快速排序\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"快速排序（Quick Sort）是一种常用的排序算法，其平均时间复杂度为O(nlogn)。在最坏情况下，时间复杂度为O(n^2)，但通过合理的选取主元 元素和随机化等方法，可以有效地避免最坏情况发生。\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"快速排序的基本思想是通过划分（Partition）将数组分为两个子数组，其中一个子数组所有元素都小于等于主元（pivot），另一个子数组所有元素都大于等于主元，然后递归地对这两个子数组进行排序，直到子数组的长度为1或为空。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"优化点\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在每次划分过程中，选择合适的主元元素对数组进行划分是影响快速排序性能的关键。通常采用以下几种方式来选择主元元素：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"选取首元素、尾元素或者中间元素作为主元。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"随机选择数组中的一个元素作为主元。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"三数取中法，选择首、尾和中间位置的元素中值作为主元。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"时间复杂度\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"快速排序的平均时间复杂度为O(nlogn)，这是由于每次划分操作都将数组划分为大致相等的两个子数组（除非数组中有重复元素，导致划分不均匀）。而每轮划分需要O(n)的时间复杂度，递归调用的次数为O(logn)。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"然而，快速排序在最坏情况下的时间复杂度为O(n^2)，当数组已经有序或基本有序时，每次划分只能将规模减小1，此时快速排序退化为了一种冒泡排序。为了避免最坏情况的发生，可以通过随机选择主元、采用三数取中法等方法来提高算法的性能。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"总结起来，快速排序的平均时间复杂度为O(nlogn)，在最坏情况下的时间复杂度为O(n^2)，并且它是一种原地排序算法，不需要额外的存储空间。\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts:快速排序\",\n        children: \"\\n  let arr = [5,2,1,6,8,3,2,9,2]\\n  function sort(arr:number[]){\\n    if(arr.length<=1) return arr;\\n    const base = arr.pop();\\n    let left = [];\\n    let right = []\\n    arr.forEach(item=>{\\n      if(item < base){\\n        left.push(item)\\n      }else{\\n        right.push(item)\\n      }\\n    })\\n    return [...sort(left),base,...sort(right)]\\n  }\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}