{"pageProps":{"metaData":{"title":"搜索","description":"搜索","tags":["算法","深度搜索","广度搜索"],"keywords":["算法","深度搜索","广度搜索"],"id":"深度搜索和广度搜索","create":1692954726915,"lastUpdate":1692954726950},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    h2: \"h2\",\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"搜索\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"深度搜索\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"深度搜索 (Depth-First Search,DFS) 是一种以深度为优先的搜索算法。它从起始节点开始，沿着路径依次探索直到达到最深处，然后回溯到上一层节点，继续向未探索的分支探索，直到遍历完整个图。DFS 通常使用递归或栈数据结构来实现。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"以下是 DFS 的基本思想：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"从起始节点开始，将其标记为已访问。\\n遍历当前节点的相邻节点，选择一个未访问过的节点作为下一个要探索的节点。\\n重复步骤 2 直到无法继续前进，然后回溯到上一层节点，继续探索未访问的节点。\\n重复步骤 2 和步骤 3 直到遍历完整个图。\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts:深度搜索\",\n        children: \"\\n  let test = [\\n    {\\n      id: 84, //标签id\\n      name: '六连包', //标签名称\\n      children: [\\n        {\\n          id: 'p_601', //标签属性名\\n          name: '可口可乐',\\n          children: [\\n            {\\n              id: 601, //标签属性id\\n              name: '可口可乐,雪碧', //标签属性名\\n            },\\n            {\\n              id: 605,\\n              name: '可口可乐芬达',\\n            },\\n          ],\\n        },\\n        {\\n          id: 'k_602',\\n          name: '大区',\\n          children: [\\n            {\\n              id: 602,\\n              name: '南区',\\n            },\\n          ],\\n        },\\n        {\\n          id: 9,\\n          name: '测试',\\n          children: [],\\n        },\\n      ],\\n    },\\n  ]\\n\\n  function findName(id, arr) {\\n    if (!Array.isArray(arr)) return '';\\n    for (let i = 0; i < arr.length; i++) {\\n      let item = arr[i];\\n      if (item.id == id) return item.name;\\n      let str = findName(id, item.children);\\n      if (str) return str;\\n    }\\n  }\\n\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"广度搜索\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"广度搜索 (Breadth-First Search,BFS) 则是一种以广度为优先的搜索算法。它从起始节点开始，逐层地扫描图中的节点，先访问离起始节点最近的节点，然后才是离起始节点稍远的节点。BFS 通常使用队列数据结构来实现。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"以下是 BFS 的基本思想：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"将起始节点放入队列，并标记为已访问。\\n从队列中取出一个节点，访问该节点并将其未访问的相邻节点加入队列。\\n重复步骤 2 直到队列为空。\\nDFS 和 BFS 在图的遍历中具有不同的特点。DFS 可以更深入地探索图的分支，适用于查找路径或遍历整个连通图。而 BFS 则逐层地扫描图的节点，适用于查找最短路径或按层级遍历图结构\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts:广度搜索\",\n        children: \"\\n  let test = [\\n    {\\n      id: 84, //标签id\\n      name: '六连包', //标签名称\\n      children: [\\n        {\\n          id: 'p_601', //标签属性名\\n          name: '可口可乐',\\n          children: [\\n            {\\n              id: 601, //标签属性id\\n              name: '可口可乐,雪碧', //标签属性名\\n            },\\n            {\\n              id: 605,\\n              name: '可口可乐芬达',\\n            },\\n          ],\\n        },\\n        {\\n          id: 'k_602',\\n          name: '大区',\\n          children: [\\n            {\\n              id: 602,\\n              name: '南区',\\n            },\\n          ],\\n        },\\n        {\\n          id: 9,\\n          name: '测试',\\n          children: [],\\n        },\\n      ],\\n    },\\n  ]\\n\\n  function findName(id,arr){\\n    let stack = [...arr];\\n    while(stack.length){\\n      let item = stack.shift();\\n      if(item.id==id) return item.name;\\n      if(Array.isArray(item.children)){\\n        stack.push(...item.children)\\n      }\\n    }\\n  }\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}