!function (e, r) {"object" == typeof exports && "undefined" != typeof module ?module.exports = r() :"function" == typeof define && define.amd?define(r) :(e = "undefined" != typeof globalThis ? globalThis : e || self).MDfiles = r()}(this, (function () { return [{"title":"H5页面，公众号/小程序内H5页面 缓存问题","brief":"# H5页面，公众号/小程序内H5页面 缓存问题\r\nH5发版之后，部分用户H5页面依旧使用的缓存","content":"# H5页面，公众号/小程序内H5页面 缓存问题\r\nH5发版之后，部分用户H5页面依旧使用的缓存<!-- more -->\r\n\r\n\r\n## 原因\r\n---\r\n    首次访问，客户端把访问页面缓存了，导致下次访问的依旧是缓存页面。被缓存的内容主要为**入口文件**和**静态资源**\r\n\r\n\r\n## 解决方案\r\n---\r\n* 入口文件:nginx中配置 Cache-Control 为 no-store, no-cache\r\n* 静态资源增加hash/版本号/时间戳","time":1669273943617},{"title":"React Native Put方式文件上传","brief":"# React Native Put方式文件上传\r\nReact Native Put文件上传方式","content":"# React Native Put方式文件上传\r\nReact Native Put文件上传方式<!-- more -->\r\n\r\n之前项目一直采用的后端上传，RN将文件使用FormData的形式传递给后端，为了解决文件过大的原因，采用RN使用PUT直接将文件上传至图片服务器;\r\n```js\r\n/**\r\n * 图片上传请求工具\r\n * @param beforeUpload \r\n * @param afterUpload \r\n * @returns \r\n */\r\nexport default async function UploadFileToOSS(\r\n    fileData: FileInfo,\r\n    beforeUpload: () => Promise<{ uploadUrl: string, key: string }>,\r\n    afterUpload: (key: string) => Promise<string>) {\r\n\r\n    // 1. 获取上传地址和key\r\n    let { uploadUrl, key } = await beforeUpload();\r\n\r\n    // fetch 为React Native 系统api\r\n    await fetch(uploadUrl, {\r\n        method: 'PUT',\r\n        body: {\r\n            uri: fileData.uri\r\n        },\r\n        headers: {\r\n            'Content-Type': fileData.type\r\n        }\r\n    })\r\n\r\n    // 3. 使用key换取上传地址\r\n    if (typeof afterUpload === 'function') {\r\n        return await afterUpload(key)\r\n    }\r\n\r\n    return key;\r\n}\r\n\r\ntype FileInfo = {\r\n    name: string\r\n    uri: string\r\n    type: string\r\n    base64: string\r\n}\r\n```\r\n","time":1669271736338},{"title":"ondrop事件不触发","brief":"# ondrop事件不触发\r\n\r\n ondrop事件不能被正确触发","content":"# ondrop事件不触发\r\n\r\n ondrop事件不能被正确触发<!-- more -->\r\n\r\n> 调用`ondragover` 并 `preventDefault`\r\n\r\n```\r\ndata/elements cannot be dropped in other elements. To allow a drop, we must prevent the default handling of the element. This is done by calling the event.preventDefault() method for the ondragover attribute\r\n```","time":1668743114963},{"title":"移动端低代码设计","brief":"# 移动端低代码设计\r\n主要就是懒得搬砖,想搞个搬砖机器人","content":"\r\n# 移动端低代码设计\r\n\r\n主要就是懒得搬砖,想搞个搬砖机器人。技术采用 `PWA` + `React` <!-- more -->\r\n\r\n目前需要要实现的功能点\r\n\r\n* 移动端尺寸问题(先固定为苹果吧，逻辑像素转化物理像素)\r\n* 基础组件(View Text Image)\r\n* 复杂组件\r\n* 拖拽(能够正确添加到对应位置)\r\n* 修改基础组件尺寸样式/对应识别复杂组件Props\r\n* JSON保存设计图\r\n* 导出React代码\r\n\r\n## UI布局模拟手机\r\n\r\nIphone8,物理像素750*1334px;逻辑像素375*667pt;规格@2x; 逻辑像素*devicePixelRatio=物理像素\r\n\r\n## 如何新增节点 并且记录节点信息\r\n","time":1669271736338},{"title":"加载JS资源","brief":"# 加载JS资源\r\n    自定义实现加载js文件资源\r\n","content":"# 加载JS资源\r\n    自定义实现加载js文件资源\r\n<!-- more -->\r\n```js\r\n/**\r\n * 加载资源\r\n * @param {string[]} paths 资源路径数组 \r\n * @param {()=>void} callback 完成回调 \r\n * @returns \r\n */\r\nfunction loadJS(paths, callback) {\r\n    if (typeof paths === 'string') {\r\n        paths = [paths]\r\n    }\r\n    if (!Array.isArray(paths) || !paths.length) return;\r\n    const [url, ...left] = paths;\r\n    const scriptDom = createElement('script');\r\n    // ie\r\n    if (scriptDom.readyState) {\r\n        scriptDom.onreadystatechange = function () {\r\n            if (scriptDom.readyState == 'loaded' || scriptDom.readyState == 'complete') {\r\n                scriptDom.onreadystatechange = null;\r\n                if (left.length) {\r\n                    loadJS(left, callback);\r\n                } else if (typeof callback === 'function') {\r\n                    callback()\r\n                }\r\n            }\r\n        };\r\n    } else {\r\n        scriptDom.onload = function () {\r\n            if (left.length) {\r\n                loadJS(left, callback);\r\n            } else if (typeof callback === 'function') {\r\n                callback()\r\n            }\r\n        };\r\n\r\n    }\r\n    scriptDom.src = url;\r\n    document.getElementsByTagName('head')[0].appendChild(scriptDom);\r\n}\r\n```","time":1665735991748},{"title":"移动 WEB 通用优化策略介绍（二）","brief":"# 移动 WEB 通用优化策略介绍（二）\r\n\r\n算起来已经足足两个半月没有更新文章，这段时间过得比较忙：夜间跑步计划、卖房买房以及工作上各种事情都凑到一块了。实际上，最近也并没有忙到完全抽不出时间写博客这种地步，根本原因可能还是变懒了，这样不好。\r\n\r\n几个月前，我决定开始写一系列有关「移动 WEB 通用优化」的文章，介绍「面向所有主流移动端浏览器（包括各种 APP 嵌入的通用 Webview）」的前端优化策略，本文是这个系列第二篇。","content":"# 移动 WEB 通用优化策略介绍（二）\r\n\r\n算起来已经足足两个半月没有更新文章，这段时间过得比较忙：夜间跑步计划、卖房买房以及工作上各种事情都凑到一块了。实际上，最近也并没有忙到完全抽不出时间写博客这种地步，根本原因可能还是变懒了，这样不好。\r\n\r\n几个月前，我决定开始写一系列有关「移动 WEB 通用优化」的文章，介绍「面向所有主流移动端浏览器（包括各种 APP 嵌入的通用 Webview）」的前端优化策略，本文是这个系列第二篇。<!-- more -->\r\n\r\n先来回顾下上篇文章最后的结论：\r\n\r\n> 重要的 CSS、JS、JSON 数据直接内联在 HTML 中，头部禁止出现任何外链资源。同时，尽可能减少页面传输体积。\r\n\r\n采用了这个策略的页面，理应能让用户在很短时间内看到主体内容，因为头部 CSS 和 JS 都内联了，不会阻塞浏览器渲染页面。在我们的认识里，浏览器会异步加载页面用到的图片，加载图片不会阻塞页面渲染，更不会阻塞 JS 执行。实际情况是这样吗？\r\n\r\n本文主要讨论在移动 WEB 中，图片的加载给页面整体性能带来的影响以及优化策略。\r\n\r\n我们知道，浏览器的 DOMContentLoaded 事件会在主页面加载并解析完成之后触发，不会等页面样式、图片、iframe 等子资源加载完。以下是 [MDN](https://developer.mozilla.org/en/docs/Web/Events/DOMContentLoaded) 对它的描述：\r\n\r\n> The DOMContentLoaded event is fired when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading. \r\n\r\n但在实际测试中，移动端完全相同的页面，加载与不加载图片对 DOMContentLoaded 触发时机的影响却很大。以下是我们在某个移动产品中，将图片延迟加载后的 DOMContentLoaded 时间对比，可以看出明显变化：\r\n\r\n<img src=\"https://st.imququ.com/static/uploads/2015/10/dom-ready-time.png\" width=\"650\" alt=\"dom ready time\" itemprop=\"image\" />\r\n\r\n我们只是将页面所有图片（大约十几张）进行延迟加载，就让 DOMContentLoaded 事件提前 250 毫秒触发。这是我之前没有意料到的，移动设备在网络、CPU、内存等方面的性能与 PC 相比差距很大，很多 PC 上可以忽略的问题，在移动端必须重视起来。\r\n\r\n移动 WEB 要做好图片优化，无外乎两点：**控制图片大小**和**控制图片加载**。\r\n\r\n### 控制图片大小\r\n\r\n图片高宽越大，意味着需要越多的网络开销。常见图片格式都经过了高度压缩，尺寸越大的图片还意味着浏览器在解码过程中需要耗费更多 CPU，解码之后的位图需要占用更多内存。在移动端，我们更应该关注图片大小。\r\n\r\n**根据 DPR（window.devicePixelRatio，设备像素比）选择合适的图片尺寸。**现在的手机基本上都是高清屏，如果一味追求让图片更小而使用单倍图也不现实。这一点上，最佳实践是根据产品特性，结合用户 DPR 分布情况来选择合适的尺寸。例如在我们某个产品中：图片加载速度比图片质量更重要；用户 DPR 分布前三是：2、3、1.5。我们最终使用了 1.5 倍图，并且在图床缩放图片时，加了一点点锐化效果。最终图片体积很小，质量也尚可接受。\r\n\r\n**处理好响应式图片（Responsive Image）。**移动上很多图片宽度不是固定像素值，例如通栏 Banner 图片的宽度是跟着设备走的。对于这种场景，使用 JS 获取设备宽度，拼出最适合当前设备的图片尺寸，交给图床进行缩放，无疑能在图片体积和质量上找到最佳平衡点。但这种做法并不可取，移动设备宽度各式各样，如果裁图规格太多，容易降低 CDN 缓存命中率。图床实时处理完图片再分发到 CDN 更耗时，在移动端让图片命中 CDN 缓存也很重要。处理响应式图片的最佳实践是根据用户屏幕尺寸分布，制定出几档裁图规则，页面根据用户设备宽度使用最合适的档位，并对重要的图片（例如头部焦点图）提前预热 CDN。\r\n\r\n> 有一项名为 HTTP Client Hints 的技术，通过新增的 HTTP 请求头部字段，使得图床可以优雅地返回最合适的图片。目前这项技术在移动端尚未普及，详情请查看 [HTTP Client Hints 介绍](https://imququ.com/post/http-client-hints.html)。\r\n\r\n**使用 WEBP 格式。**有一种减少图片体积的灵丹妙药 —— 使用压缩比例更高的 WEBP 格式。《[移动端图片格式调研](http://blog.ibireme.com/2015/11/02/mobile_image_benchmark/)》这篇文章详细地对比了各种移动端图片格式及各自适用场景。对于 WEBP 的最佳实践是只要浏览器支持就用，虽然 WEBP 解码慢于 JPG，但在同等图片质量下，WEBP 体积通常比 JPG 小很多。\r\n\r\n要判断浏览器是否支持 WEBP，可以检查 HTTP 请求头部字段 `Accept` 的值是否包含 `webp`。例如这是 Chrome 给图片请求加的 `Accept`：\r\n\r\n```\r\nAccept: image/webp,image/*,*/*;q=0.8\r\n```\r\n\r\n不是所有支持 WEBP 的浏览器都会这样处理，可以针对这种情况使用特性检测：\r\n\r\n```js\r\nvar webpImg = new Image;\r\nwebpImg.onload = function () {\r\n    if(webpImg.width == 1){\r\n        cookie('env_webp', 1); //cookie 方法需要自己实现\r\n    }\r\n};\r\nwebpImg.src = 'data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoBAAEAAgA0JaQAA3AA/vv9UAA=';\r\n```\r\n\r\n这段示意代码的原理是：用 JS 加载 WEBP 图片，如果能触发 onload 并获取到宽度，说明当前浏览器支持 WEBP。\r\n\r\n### 控制图片加载\r\n\r\n我在《[AMP，来自 Google 的移动页面优化方案](https://imququ.com/post/amp-project.html)》一文中写到：「将图片、视频等标签和第三方功能换成 AMP Components 后，AMP Runtime 可以自动处理延迟加载、按需加载等逻辑，确保页面首屏性能」。在移动浏览器打开网页，经常能感觉到明显的卡顿。造成卡顿的原因除了页面 DOM 结构复杂、CSS 过多地触发 Layout/Paint/Composite、存在复杂 JS 逻辑等等，也可能是没有控制图片的加载时机。\r\n\r\n通常浏览器会并发加载 6 个同域名图片，如果做了域名散列，那很可能在打开页面后的短短几秒内，几十个图片都在加载。这些连接带来的 TCP、带宽、CPU、内存等开销，很容易让页面卡顿。所以在移动端，我们要让图片加载变得可控。\r\n\r\n**按需加载图片。**在 PC 端，我们基本都会做图片 Lazy Load，这个优化策略在移动端同样适用。由于移动端性能有限、带宽昂贵，Lazy Load 更为重要。实际上不光是图片可以做 Lazy Load，页面所有资源包括 DOM 节点都应该做成按需加载。通常在移动端，我们只加载页面可视区域及其下方一定距离内的资源。\r\n\r\n**顺序加载图片。**在 PC 端，由于硬件性能和带宽足够，并行加载更多的图片通常是最好的选择。而在移动端，人为控制图片加载顺序，例如使其从上到下、从左到右逐个加载，有时可以带来更好的体验。\r\n\r\n**不要在页面滚定时加载图片。**按需加载图片逻辑需要监听页面滚动事件，根据页面当前可视区域决定加载哪些图片。在移动端滚动页面本来就很耗费性能，如果这时候还要加载图片，非常容易造成页面卡顿。在页面滚定停止之后才开始载入图片，能有效减少这种卡顿。\r\n\r\n好了，本文先就写这么多。还是老规矩，有任何问题和疑问欢迎留言讨论。Disqus 最近在国内经常无法加载，怎么处理你们都懂的。实在不行也可以给我发邮件，本站「关于」页面有我的邮箱。\r\n\r\n原文链接：[https://imququ.com/post/wpo-of-mobile-web-2.html](https://imququ.com/post/wpo-of-mobile-web-2.html)，[前往原文评论 »](https://imququ.com/post/wpo-of-mobile-web-2.html#comments)\r\n","time":1665649131964},{"title":"JS正则非","brief":"# JS正则非\r\n为单字符匹配，[^abc]表示非a非b非c","content":"# JS正则非\r\n为单字符匹配，[^abc]表示非a非b非c<!-- more -->\r\n\r\n```js\r\nconst regexp = /<[^>]*>/ \r\nregexp.exec(\"<long>jiang>\") // <long>\r\n```\r\n","time":1665649468941},{"title":"从启用 HTTP/2 导致网站无法访问说起","brief":"# 从启用 HTTP/2 导致网站无法访问说起\r\n\r\n最近好几个朋友在给网站开启 HTTP/2 后，都遇到了无法访问的问题。其中有的网站只是 Firefox 无法访问，通过控制台网络面板可以看到请求被 Abort；有的网站不但 Firefox 无法访问，连 Chrome 也会跳到错误页，错误代码是「ERR\\_SPDY\\_INADEQUATE\\_TRANSPORT\\_SECURITY」。诡异的是，只要去掉对 HTTP/2 的支持（例如去掉 Nginx listen 配置中的 http2）就一切正常。也就是说无法访问的现象只存在于 HTTPS + HTTP/2 的组合，单独提供 HTTPS 服务时就是好的。\r\n\r\n这个问题比较有趣，本文除了告诉大家如何解决它之外，还会帮助大家弄清问题的来龙去脉。如果你只关心结论，直接看最后的小结即可。","content":"# 从启用 HTTP/2 导致网站无法访问说起\r\n\r\n最近好几个朋友在给网站开启 HTTP/2 后，都遇到了无法访问的问题。其中有的网站只是 Firefox 无法访问，通过控制台网络面板可以看到请求被 Abort；有的网站不但 Firefox 无法访问，连 Chrome 也会跳到错误页，错误代码是「ERR\\_SPDY\\_INADEQUATE\\_TRANSPORT\\_SECURITY」。诡异的是，只要去掉对 HTTP/2 的支持（例如去掉 Nginx listen 配置中的 http2）就一切正常。也就是说无法访问的现象只存在于 HTTPS + HTTP/2 的组合，单独提供 HTTPS 服务时就是好的。\r\n\r\n这个问题比较有趣，本文除了告诉大家如何解决它之外，还会帮助大家弄清问题的来龙去脉。如果你只关心结论，直接看最后的小结即可。<!-- more -->\r\n\r\n首先，网站无法访问有很多种可能，一般要从基本项开始检查：\r\n\r\n* 是否网络不通（可以通过能否访问 [imququ.com](https://imququ.com) 来排查 ^_^）；\r\n* 网站 DNS 解析是否正常（可以通过 ping、nslookup、dig 等工具来排查）；\r\n* TCP 连接能否建立（可以通过 telnet 来排查，例如 telnet imququ.com 443）；\r\n\r\n如果 TCP 连接能够建立，至少说明 Web Server 在运行，本地到 Web Server 网络也正常。如果还有问题，就要开始往应用层去排查，例如：\r\n\r\n* 是否因为域名没备案被阻止（可以尝试用 IP，或者换非标准端口访问）；\r\n* 是否因为 Web 程序太慢，迟迟没返回响应（通过浏览器网络面板可以看到请求状态一直是 pending）；\r\n* 是否有响应，只是内容为空（根据响应状态码，排查服务端配置或业务代码）；\r\n\r\n对于 HTTPS 网站，HTTP 和 TCP 中间多了一层 TLS。在浏览器发送 HTTP 报文前，还得先跟服务端建立 TLS 连接，这个过程非常复杂，也很容易出问题。例如：\r\n\r\n* 没有合法的证书（已过期、域名不匹配等等，一般浏览器都会给出明确的提示。需要特别排查同 IP 部署多 HTTPS 站点时，由于客户端不支持 SNI 导致的证书不合法问题）；\r\n* 使用了浏览器不支持的证书类型（例如没有打 XP SP3 补丁的 IE6 不支持 SHA-2 证书）；\r\n* 使用了浏览器不支持的 TLS 协议版本（例如 IE6 默认只支持 SSLv2 和 SSLv3）；\r\n* 使用了浏览器不支持的 CipherSuite（例如 ECDHE-ECDSA-CHACHA20-POLY1305 只有 Chrome 支持）；\r\n\r\n关于部署 HTTPS 时的一些注意事项，可以参考我之前的「[对于关于启用 HTTPS 的一些经验分享（二）](https://imququ.com/post/sth-about-switch-to-https-2.html)」这篇文章，这不是本文重点，故不展开讨论。\r\n\r\n总之前面列了这么多可能，跟本文要解决的问题**基本没有任何关系**！如果是因为响应迟迟没有回来，或者是证书不合法导致的无法访问，完全没有道理不启用 HTTP/2 就是好的。\r\n\r\n实际上，Chrome 这个「ERR\\_SPDY\\_INADEQUATE\\_TRANSPORT\\_SECURITY」错误代码已经给出了两个提示：\r\n\r\n1. 与 HTTP/2 有关。SPDY 是 HTTP/2 的前身，这个错误码应该是从 SPDY 时代沿用下来的；\r\n1. 与 TLS 安全有关。对于有安全隐患的 HTTPS 站点，现代浏览器会阻止 TLS 握手成功。例如最新的 Chrome 48 会拒绝与「以 RC4 做为对称加密算法的 CipherSuite」建立 TLS 连接；\r\n\r\n通过 Wireshark 抓包可以看到：这个案例中，浏览器在 TLS 握手阶段发送了「Encrypted Alert」，然后主动断开了 TCP。TLS 连接都没有建立成功，页面当然无法访问了。\r\n\r\n之前阅读 HTTP/2 RFC 时，我了解到 HTTP/2 协议中对 TLS 有了更严格的限制：例如 HTTP/2 中只能使用 TLSv1.2+，还禁用了几百种 CipherSuite（详见：[TLS 1.2 Cipher Suite Black List](http://http2.github.io/http2-spec/#BadCipherSuites)）。至此可以肯定，之所以出现这个错误，要么是服务端没有启用 TLSv1.2，要么是 CipherSuite 配置有问题。本案例中，服务端支持 TLSv1.2，只可能是后者有问题。\r\n\r\nCipherSuite，也就是加密套件，在整个 TLS 协议中至关重要，详细介绍可以参考[我之前的文章](https://imququ.com/post/sth-about-switch-to-https-2.html#toc-1)。\r\n\r\n建立 TLS 连接时，浏览器需要在 Client Hello 握手中提供自己支持的 CipherSuite 列表和应用协议列表（通过 TLS ALPN 扩展），服务端则通过 Server Hello 握手返回选定的 CipherSuite 和应用协议。如果服务端选定的应用协议是 HTTP/2，浏览器就需要检查 CipherSuite 是否在 HTTP/2 的黑名单之中，如果存在就终止 TLS 握手。\r\n\r\n当然，如果浏览器本身不支持 HTTP/2，Client Hello 握手中的 ALPN 扩展中就不会包含 h2（实际上，ALPN 扩展都不一定存在），服务端也不会选定 HTTP/2 做为后续应用协议。实际上，这个过程就是 HTTP/2 协议协商机制。\r\n\r\nHTTP/2 对 CipherSuite 有更严格的限制，用于承载 HTTP/1.1 加密流量的 CipherSuite，不一定能用于承载 HTTP/2 加密流量。这也导致之前运行良好的 HTTPS 站点，在启用 HTTP/2 后，可能会由于 CipherSuite 被禁用导致无法通过 HTTP/2 访问。\r\n\r\n明白了原理，再来看一个具体案例（注：本案例来自于本博客网友评论，[via](https://imququ.com/post/nginx-http2-patch.html#comment-2304827417)）：\r\n\r\n> 在 Nginx 中配置以下 CipherSuite 并启用 HTTP/2，在最新的 Firefox 中无法访问：\r\n> \r\n> ssl\\_ciphers ECDHE-RSA-CHACHA20-POLY1305:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:AES256-GCM-SHA384:AES256-SHA256:AES256-SHA:AES128-GCM-SHA256:AES128-SHA256:AES128-SHA:ECDHE-RSA-DES-CBC3-SHA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!CAMELLIA:!DES:!MD5:!PSK:!RC4;\r\n\r\n注：上述配置中的 CHACHA20/POLY1305，由 Google 开发。以前需要使用 [LibreSSL](https://libressl.org/)、[BoringSSL](https://boringssl.googlesource.com/boringssl/) 或者 CloudFlare 的 [OpenSSL Patch](https://github.com/cloudflare/sslconfig) 才能支持它，最新版的 OpenSSL 已经内置了对它的支持（[via](https://www.openssl.org/news/changelog.txt)）。\r\n\r\n先来看看上述配置指定的 CipherSuite 具体有哪些（注：以下命令中的 openssl 版本是 LibreSSL 2.3.1）：\r\n\r\n```bash\r\nopenssl ciphers -V 'ECDHE-RSA-CHACHA20-POLY1305:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:AES256-GCM-SHA384:AES256-SHA256:AES256-SHA:AES128-GCM-SHA256:AES128-SHA256:AES128-SHA:ECDHE-RSA-DES-CBC3-SHA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!CAMELLIA:!DES:!MD5:!PSK:!RC4' | column -t\r\n```\r\n\r\n运行结果如下：\r\n\r\n```\r\n0xCC,0x13  -  ECDHE-RSA-CHACHA20-POLY1305  TLSv1.2  Kx=ECDH  Au=RSA  Enc=ChaCha20-Poly1305  Mac=AEAD\r\n0xC0,0x30  -  ECDHE-RSA-AES256-GCM-SHA384  TLSv1.2  Kx=ECDH  Au=RSA  Enc=AESGCM(256)        Mac=AEAD\r\n0xC0,0x28  -  ECDHE-RSA-AES256-SHA384      TLSv1.2  Kx=ECDH  Au=RSA  Enc=AES(256)           Mac=SHA384\r\n0xC0,0x14  -  ECDHE-RSA-AES256-SHA         SSLv3    Kx=ECDH  Au=RSA  Enc=AES(256)           Mac=SHA1\r\n0xC0,0x2F  -  ECDHE-RSA-AES128-GCM-SHA256  TLSv1.2  Kx=ECDH  Au=RSA  Enc=AESGCM(128)        Mac=AEAD\r\n0xC0,0x27  -  ECDHE-RSA-AES128-SHA256      TLSv1.2  Kx=ECDH  Au=RSA  Enc=AES(128)           Mac=SHA256\r\n0xC0,0x13  -  ECDHE-RSA-AES128-SHA         SSLv3    Kx=ECDH  Au=RSA  Enc=AES(128)           Mac=SHA1\r\n0x00,0x9D  -  AES256-GCM-SHA384            TLSv1.2  Kx=RSA   Au=RSA  Enc=AESGCM(256)        Mac=AEAD\r\n0x00,0x3D  -  AES256-SHA256                TLSv1.2  Kx=RSA   Au=RSA  Enc=AES(256)           Mac=SHA256\r\n0x00,0x35  -  AES256-SHA                   SSLv3    Kx=RSA   Au=RSA  Enc=AES(256)           Mac=SHA1\r\n0x00,0x9C  -  AES128-GCM-SHA256            TLSv1.2  Kx=RSA   Au=RSA  Enc=AESGCM(128)        Mac=AEAD\r\n0x00,0x3C  -  AES128-SHA256                TLSv1.2  Kx=RSA   Au=RSA  Enc=AES(128)           Mac=SHA256\r\n0x00,0x2F  -  AES128-SHA                   SSLv3    Kx=RSA   Au=RSA  Enc=AES(128)           Mac=SHA1\r\n0xC0,0x12  -  ECDHE-RSA-DES-CBC3-SHA       SSLv3    Kx=ECDH  Au=RSA  Enc=3DES(168)          Mac=SHA1\r\n0x00,0x0A  -  DES-CBC3-SHA                 SSLv3    Kx=RSA   Au=RSA  Enc=3DES(168)          Mac=SHA1\r\n```\r\n\r\n再通过 Wireshark 获得 Firefox 在 Client Hello 中发送的 CipherSuite 列表，如下：\r\n\r\n```\r\nTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 (0xC0,0x2B)\r\nTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xC0,0x2F)\r\nTLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA (0xC0,0x0A)\r\nTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA (0xC0,0x09)\r\nTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA (0xC0,0x13)\r\nTLS_ECDHE_RSA_WITH_AES_256_CBC_SHA (0xC0,0x14)\r\nTLS_DHE_RSA_WITH_AES_128_CBC_SHA (0x00,0x33)\r\nTLS_DHE_RSA_WITH_AES_256_CBC_SHA (0x00,0x39)\r\nTLS_RSA_WITH_AES_128_CBC_SHA (0x00,0x2F)\r\nTLS_RSA_WITH_AES_256_CBC_SHA (0x00,0x35)\r\nTLS_RSA_WITH_3DES_EDE_CBC_SHA (0x00,0x0A)\r\n```\r\n\r\nCipherSuite 协商目的是找出两端都支持的套件，也就是取出二者的交集：\r\n\r\n```\r\nTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xC0,0x2F)\r\nTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA (0xC0,0x13)\r\nTLS_ECDHE_RSA_WITH_AES_256_CBC_SHA (0xC0,0x14)\r\nTLS_RSA_WITH_AES_128_CBC_SHA (0x00,0x2F)\r\nTLS_RSA_WITH_AES_256_CBC_SHA (0x00,0x35)\r\nTLS_RSA_WITH_3DES_EDE_CBC_SHA (0x00,0x0A)\r\n```\r\n\r\n乍一看选择余地还挺大，但别忘了，HTTP/2 协议中还禁用了好几百个。把这部分去掉后只剩下：\r\n\r\n```\r\nTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xC0,0x2F)\r\n```\r\n\r\n奇怪的是，好歹还有一个满足所有条件的套件，为什么还是会握手失败呢？通过 Wireshark 看一下 Server Hello 会发现：在这个案例中，通过 Firefox 访问，服务端选定的套件是 `0xC0,0x14`，并不是 `0xC0,0x2F`。\r\n\r\nNginx 有一个 `ssl_prefer_server_ciphers` 配置，如果设置为 `on`，表示在协商 CipherSuite 时，算出交集后，会按照服务端配置的套件列表顺序返回第一个，这样可以提高安全性。而那份配置的 `ssl_ciphers` 中，`0xC0,0x14` 排在了 \r\n`0xC0,0x2F` 前面，开启 `ssl_prefer_server_ciphers` 后，会使得被 HTTP/2 禁用的 `0xC0,0x14` 选中，从而导致最终 HTTPS + HTTP/2 握手失败。\r\n\r\n那为什么这份配置在 Chrome 中是正常的呢？Chrome 支持的 CipherSuite 如下，大家可以自己分析下。\r\n\r\n```\r\nTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 (0xC0,0x2B)\r\nTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xC0,0x2F)\r\nTLS_DHE_RSA_WITH_AES_128_GCM_SHA256 (0x00,0x9E)\r\nTLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 (0xCC,0x14)\r\nTLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 (0xCC,0x13)\r\nTLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA (0xC0,0x0A)\r\nTLS_ECDHE_RSA_WITH_AES_256_CBC_SHA (0xC0,0x14)\r\nTLS_DHE_RSA_WITH_AES_256_CBC_SHA (0x00,0x39)\r\nTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA (0xC0,0x09)\r\nTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA (0xC0,0x13)\r\nTLS_DHE_RSA_WITH_AES_128_CBC_SHA (0x00,0x33)\r\nTLS_RSA_WITH_AES_128_GCM_SHA256 (0x00,0x9C)\r\nTLS_RSA_WITH_AES_256_CBC_SHA (0x00,0x35)\r\nTLS_RSA_WITH_AES_128_CBC_SHA (0x00,0x2F)\r\nTLS_RSA_WITH_3DES_EDE_CBC_SHA (0x00,0x0A)\r\n```\r\n\r\n针对这个案例，将 Nginx 配置中的 `0xC0,0x2F`（ECDHE-RSA-AES128-GCM-SHA256）挪到 `0xC0,0x14`（ECDHE-RSA-AES256-SHA） \r\n之前，即可解决最新 Firefox 下无法访问的问题。当然，正如我在以往文章中多次强调的，配置 TLS 时务必参考权威文档，例如：[Mozilla 的推荐配置](https://wiki.mozilla.org/Security/Server_Side_TLS#Recommended_configurations)、[CloudFlare 使用的配置](https://github.com/cloudflare/sslconfig/blob/master/conf)。经过测试，使用这两份配置的 HTTPS 站点在启用 HTTP/2 后都没有问题。\r\n\r\n简单小结一下，对于能正常工作的 HTTPS 网站启用 HTTP/2 后出现无法访问的问题，请排查服务端这两点配置：1）是否启用了 TLSv1.2；2）是否正确配置了 CipherSuite。\r\n\r\n本文就写到这里。大家平时遇到有关 HTTP(S)、HTTP/2 的问题，欢迎给我留言或者发邮件讨论。\r\n\r\n原文链接：[https://imququ.com/post/why-tls-handshake-failed-with-http2-enabled.html](https://imququ.com/post/why-tls-handshake-failed-with-http2-enabled.html)，[前往原文评论 »](https://imququ.com/post/why-tls-handshake-failed-with-http2-enabled.html#comments)\r\n","time":1665649131964}]}))