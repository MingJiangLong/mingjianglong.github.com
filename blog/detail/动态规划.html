<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>(*^▽^*)</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/80a95484ea2876e6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/80a95484ea2876e6.css" data-n-g=""/><link rel="preload" href="/_next/static/css/f8f6338530cfd437.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f8f6338530cfd437.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee7e63bc15b31913.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-7477d36a73a3487c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d15f243f6b85624f.js" defer=""></script><script src="/_next/static/chunks/171-0943d13a71220321.js" defer=""></script><script src="/_next/static/chunks/pages/blog/detail/%5Bid%5D-0499978da9bd8e44.js" defer=""></script><script src="/_next/static/HZJv74Pq-2_9EJ9ksPX8e/_buildManifest.js" defer=""></script><script src="/_next/static/HZJv74Pq-2_9EJ9ksPX8e/_ssgManifest.js" defer=""></script><style id="__jsx-1471609662">.file-name-container.jsx-1471609662{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;width:100%;max-width:100%;background-color:#1d2b35d9;padding:-webkit-calc(.5rem + .2vw);padding:-moz-calc(.5rem + .2vw);padding:calc(.5rem + .2vw);-webkit-border-top-left-radius:5px;-moz-border-radius-topleft:5px;border-top-left-radius:5px;-webkit-border-top-right-radius:5px;-moz-border-radius-topright:5px;border-top-right-radius:5px;margin-top:1vh;white-space:pre-wrap;word-wrap:break-word;overflow-wrap:break-word}.file-name.jsx-1471609662{font-family:"Share Tech Mono",monospace;font-size:-webkit-calc(.9rem + .1vw);font-size:-moz-calc(.9rem + .1vw);font-size:calc(.9rem + .1vw);color:#fffecbf2}</style></head><body><div id="__next"><div class="layout_main-container__jR90l"><main class="layout_main__E22hH"><div style="width:15em"><nav class="sidebar_nav__EFmKd"><div class="Avatar_container__egCID"><div class="Avatar_image-container__9WrGh"><img src="/images/avatar.png" alt="mingjianglong" class="Avatar_avatar__oORu6"/><h2>龙江</h2><h3 style="font-weight:normal;padding-top:.6em;color:grey">Jiang Long</h3><h4 style="padding-top:1.3em">等风也等你~</h4><span class="Avatar_my-face__hbhE_">ღゝ◡╹)ノ♡</span></div><div></div></div><a style="color:black" href="/">开心☺</a><a style="color:black" href="/blog">Blog</a><a style="color:black" href="/archive">归档</a><a style="color:black" href="/resume">简介</a></nav></div><div style="flex:1;height:100vh;display:flex;flex-direction:column;overflow-y:hidden"><div style="height:100%;padding:7em;overflow:scroll"><h1 style="font-family:&#x27;Ubuntu&#x27;, sans-serif;font-size:calc(1rem + 1.5vw);color:#1d2b35;padding:1em 0;overflow-wrap:break-word">动态规划</h1>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">动态规划最核心的思想，就在于拆分子问题，记住过往，减少重复计算。</p>
<ul style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013e6;margin:1vh 0 1vh calc(2vw);overflow-wrap:break-word">
<li>A ： &quot;1+1+1+1+1+1+1+1 =？&quot;</li>
<li>A ： &quot;上面等式的值是多少&quot;</li>
<li>B ： 计算 &quot;8&quot;</li>
<li>A : 在上面等式的左边写上 &quot;1+&quot; 呢？</li>
<li>A : &quot;此时等式的值为多少&quot;</li>
<li>B : 很快得出答案 &quot;9&quot;</li>
<li>A : &quot;你怎么这么快就知道答案了&quot;</li>
<li>A : &quot;只要在8的基础上加1就行了&quot;</li>
<li>A : &quot;所以你不用重新计算，因为你记住了第一个等式的值为8!动态规划算法也可以说是 &#x27;记住求过的解来节省时间&#x27;&quot;</li>
</ul>
<h3 style="font-family:&#x27;Maven Pro&#x27;, sans-serif;font-size:calc(1rem + 0.5vw);color:#1d2b35;padding:.6em 0;overflow-wrap:break-word">斐波那契数列</h3>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">指的是这样一个数列：这个数列从第3项开始，每一项都等于前两项之和。
F(0) = 0,F(1) = 1, F(n) = F(n - 1) + F(n - 2),</p>
<pre><div class="jsx-1471609662"><div class="jsx-1471609662 file-name-container"><p class="jsx-1471609662 file-name">动态规划-斐波那契数列</p></div><pre class="language-js:动态规划-斐波那契数列" style="color:#1d2b35;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.2;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:0px;overflow:auto;background:#1e1e1e;background-color:#071013f2;padding-bottom:1em;margin-bottom:1vh;border-bottom-left-radius:5px;border-bottom-right-radius:5px"><code class="language-js" style="color:#d4d4d4;font-size:calc(0.8rem + 0.1vw);text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.2;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>  </span><span class="token" style="color:#569CD6">function</span><span> </span><span class="token" style="color:#dcdcaa">fibonacciDynamic</span><span class="token" style="color:#d4d4d4">(</span><span class="token" style="color:#9cdcfe">n</span><span class="token" style="color:#d4d4d4">)</span><span> </span><span class="token" style="color:#d4d4d4">{</span><span>
</span><span>    </span><span class="token" style="color:#c586c0">if</span><span class="token" style="color:#d4d4d4">(</span><span>n </span><span class="token" style="color:#d4d4d4">&lt;=</span><span> </span><span class="token" style="color:#b5cea8">1</span><span> </span><span class="token" style="color:#d4d4d4">)</span><span> </span><span class="token" style="color:#c586c0">return</span><span> n</span><span class="token" style="color:#d4d4d4">;</span><span>
</span><span>    </span><span class="token" style="color:#569CD6">let</span><span> dp </span><span class="token" style="color:#d4d4d4">=</span><span> </span><span class="token" style="color:#d4d4d4">[</span><span class="token" style="color:#d4d4d4">]</span><span class="token" style="color:#d4d4d4">;</span><span>
</span><span>    dp</span><span class="token" style="color:#d4d4d4">[</span><span class="token" style="color:#b5cea8">0</span><span class="token" style="color:#d4d4d4">]</span><span> </span><span class="token" style="color:#d4d4d4">=</span><span> </span><span class="token" style="color:#b5cea8">0</span><span class="token" style="color:#d4d4d4">;</span><span> dp</span><span class="token" style="color:#d4d4d4">[</span><span class="token" style="color:#b5cea8">1</span><span class="token" style="color:#d4d4d4">]</span><span> </span><span class="token" style="color:#d4d4d4">=</span><span> </span><span class="token" style="color:#b5cea8">1</span><span class="token" style="color:#d4d4d4">;</span><span>
</span>
<span>    </span><span class="token" style="color:#c586c0">for</span><span class="token" style="color:#d4d4d4">(</span><span class="token" style="color:#569CD6">let</span><span> i </span><span class="token" style="color:#d4d4d4">=</span><span> </span><span class="token" style="color:#b5cea8">2</span><span class="token" style="color:#d4d4d4">;</span><span>i </span><span class="token" style="color:#d4d4d4">&lt;=</span><span> n</span><span class="token" style="color:#d4d4d4">;</span><span> i</span><span class="token" style="color:#d4d4d4">++</span><span class="token" style="color:#d4d4d4">)</span><span class="token" style="color:#d4d4d4">{</span><span>
</span><span>      dp</span><span class="token" style="color:#d4d4d4">[</span><span>i</span><span class="token" style="color:#d4d4d4">]</span><span> </span><span class="token" style="color:#d4d4d4">=</span><span> dp</span><span class="token" style="color:#d4d4d4">[</span><span>i</span><span class="token" style="color:#d4d4d4">-</span><span class="token" style="color:#b5cea8">2</span><span class="token" style="color:#d4d4d4">]</span><span class="token" style="color:#d4d4d4">+</span><span>dp</span><span class="token" style="color:#d4d4d4">[</span><span>i</span><span class="token" style="color:#d4d4d4">-</span><span class="token" style="color:#b5cea8">1</span><span class="token" style="color:#d4d4d4">]</span><span>
</span><span>    </span><span class="token" style="color:#d4d4d4">}</span><span>
</span><span>    </span><span class="token" style="color:#c586c0">return</span><span> dp</span><span class="token" style="color:#d4d4d4">[</span><span>n</span><span class="token" style="color:#d4d4d4">]</span><span>
</span><span>  </span><span class="token" style="color:#d4d4d4">}</span><span>
</span></code></pre></div></pre>
<h3 style="font-family:&#x27;Maven Pro&#x27;, sans-serif;font-size:calc(1rem + 0.5vw);color:#1d2b35;padding:.6em 0;overflow-wrap:break-word">青蛙跳阶问题</h3>
<ul style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013e6;margin:1vh 0 1vh calc(2vw);overflow-wrap:break-word">
<li>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</li>
</ul>
<blockquote style="font-style:italic;background-color:#20a4f326;padding:10px;margin:1vh 0 1vh 0;border-left:5px solid #20a4f3e6">
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">f(n) = f(n-1) + f(n-2)</p>
</blockquote>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">对于一般情况的n，青蛙跳上第n级台阶有两种方式：</p>
<ul style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013e6;margin:1vh 0 1vh calc(2vw);overflow-wrap:break-word">
<li>青蛙<span class="SyntaxHighlighter_key-words__9bKIe">从第n-1级台阶跳上来</span>：这种情况下，青蛙只需要从第n-1级台阶跳1级就能到达第n级台阶，所以这种方式的跳法数量为f(n-1)。</li>
<li>青蛙<span class="SyntaxHighlighter_key-words__9bKIe">从第n-2级台阶跳上来</span>：这种情况下，青蛙需要从第n-2级台阶跳2级才能到达第n级台阶，所以这种方式的跳法数量为f(n-2)。</li>
</ul>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">一只青蛙跳上n级的台阶有多少种跳法。</p>
<blockquote style="font-style:italic;background-color:#20a4f326;padding:10px;margin:1vh 0 1vh 0;border-left:5px solid #20a4f3e6">
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">f(n) = 2*f(n-1)  |  2^(n-1)</p>
</blockquote>
<h3 style="font-family:&#x27;Maven Pro&#x27;, sans-serif;font-size:calc(1rem + 0.5vw);color:#1d2b35;padding:.6em 0;overflow-wrap:break-word">下降路径最小和</h3>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">给你一个 n x n 整数矩阵 grid ，请你返回 非零偏移下降路径 数字和的最小值。</p>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">输入：grid = [[1,2,3],[4,5,6],[7,8,9]]</p>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">输出：13</p>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">解释：
所有非零偏移下降路径包括：</p>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">[1,5,9], [1,5,7], [1,6,7], [1,6,8],</p>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">[2,4,8], [2,4,9], [2,6,7], [2,6,8],</p>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">[3,4,8], [3,4,9], [3,5,7], [3,5,9]</p>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">下降路径中数字和最小的是 [1,5,7] ，所以答案是 13 。</p>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">解题思路:</p>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">dp[i][j] 表示 第i行第j个元素的最小路径和</p>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">grid[i[j] 下降路径第i行第j个元素</p>
<blockquote style="font-style:italic;background-color:#20a4f326;padding:10px;margin:1vh 0 1vh 0;border-left:5px solid #20a4f3e6">
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">dp[i][j] = dp[i-1][j] + grid[i[j]</p>
</blockquote>
<pre><div class="jsx-1471609662"><div class="jsx-1471609662 file-name-container"><p class="jsx-1471609662 file-name">下降路径最小和</p></div><pre class="language-js:下降路径最小和" style="color:#1d2b35;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.2;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:0px;overflow:auto;background:#1e1e1e;background-color:#071013f2;padding-bottom:1em;margin-bottom:1vh;border-bottom-left-radius:5px;border-bottom-right-radius:5px"><code class="language-js" style="color:#d4d4d4;font-size:calc(0.8rem + 0.1vw);text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.2;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>
</span><span></span><span class="token doc-comment" style="color:#6a9955">/**
</span><span class="token doc-comment" style="color:#6a9955"> * </span><span class="token doc-comment" style="color:#569CD6">@param</span><span class="token doc-comment" style="color:#6a9955"> </span><span class="token doc-comment" style="color:#d4d4d4">{</span><span class="token doc-comment" style="color:#4ec9b0">number</span><span class="token doc-comment" style="color:#d4d4d4">[</span><span class="token doc-comment" style="color:#d4d4d4">]</span><span class="token doc-comment" style="color:#d4d4d4">[</span><span class="token doc-comment" style="color:#d4d4d4">]</span><span class="token doc-comment" style="color:#d4d4d4">}</span><span class="token doc-comment" style="color:#6a9955"> </span><span class="token doc-comment" style="color:#9cdcfe">grid</span><span class="token doc-comment" style="color:#6a9955">
</span><span class="token doc-comment" style="color:#6a9955"> * </span><span class="token doc-comment" style="color:#569CD6">@return</span><span class="token doc-comment" style="color:#6a9955"> </span><span class="token doc-comment" style="color:#d4d4d4">{</span><span class="token doc-comment" style="color:#4ec9b0">number</span><span class="token doc-comment" style="color:#d4d4d4">}</span><span class="token doc-comment" style="color:#6a9955">
</span><span class="token doc-comment" style="color:#6a9955"> * dp[i][j] 表示 第i行第j个元素的最小路径和
</span><span class="token doc-comment" style="color:#6a9955"> * dp[i][j] =min(dp[i-1][j])
</span><span class="token doc-comment" style="color:#6a9955"> */</span><span>
</span><span></span><span class="token" style="color:#569CD6">function</span><span> </span><span class="token" style="color:#dcdcaa">minFallingPathSum</span><span> </span><span class="token" style="color:#d4d4d4">(</span><span class="token" style="color:#9cdcfe">grid</span><span class="token" style="color:#d4d4d4">)</span><span> </span><span class="token" style="color:#d4d4d4">{</span><span>
</span>
<span>    </span><span class="token" style="color:#569CD6">let</span><span> dp </span><span class="token" style="color:#d4d4d4">=</span><span> </span><span class="token" style="color:#d4d4d4">[</span><span class="token" style="color:#d4d4d4">[</span><span class="token spread" style="color:#d4d4d4">...</span><span>grid</span><span class="token" style="color:#d4d4d4">[</span><span class="token" style="color:#b5cea8">0</span><span class="token" style="color:#d4d4d4">]</span><span class="token" style="color:#d4d4d4">]</span><span class="token" style="color:#d4d4d4">]</span><span>
</span><span>    </span><span class="token" style="color:#c586c0">for</span><span> </span><span class="token" style="color:#d4d4d4">(</span><span class="token" style="color:#569CD6">let</span><span> i </span><span class="token" style="color:#d4d4d4">=</span><span> </span><span class="token" style="color:#b5cea8">1</span><span class="token" style="color:#d4d4d4">;</span><span> i </span><span class="token" style="color:#d4d4d4">&lt;</span><span> grid</span><span class="token" style="color:#d4d4d4">.</span><span class="token property-access">length</span><span class="token" style="color:#d4d4d4">;</span><span> i</span><span class="token" style="color:#d4d4d4">++</span><span class="token" style="color:#d4d4d4">)</span><span> </span><span class="token" style="color:#d4d4d4">{</span><span>
</span><span>        dp</span><span class="token" style="color:#d4d4d4">[</span><span>i</span><span class="token" style="color:#d4d4d4">]</span><span> </span><span class="token" style="color:#d4d4d4">=</span><span> </span><span class="token" style="color:#d4d4d4">[</span><span class="token" style="color:#d4d4d4">]</span><span>
</span><span>        </span><span class="token" style="color:#c586c0">for</span><span> </span><span class="token" style="color:#d4d4d4">(</span><span class="token" style="color:#569CD6">let</span><span> j </span><span class="token" style="color:#d4d4d4">=</span><span> </span><span class="token" style="color:#b5cea8">0</span><span class="token" style="color:#d4d4d4">;</span><span> j </span><span class="token" style="color:#d4d4d4">&lt;</span><span> grid</span><span class="token" style="color:#d4d4d4">[</span><span>i</span><span class="token" style="color:#d4d4d4">]</span><span class="token" style="color:#d4d4d4">.</span><span class="token property-access">length</span><span class="token" style="color:#d4d4d4">;</span><span> j</span><span class="token" style="color:#d4d4d4">++</span><span class="token" style="color:#d4d4d4">)</span><span> </span><span class="token" style="color:#d4d4d4">{</span><span>
</span><span>            </span><span class="token" style="color:#569CD6">let</span><span> min</span><span class="token" style="color:#d4d4d4">;</span><span>
</span><span>            </span><span class="token" style="color:#c586c0">for</span><span> </span><span class="token" style="color:#d4d4d4">(</span><span class="token" style="color:#569CD6">let</span><span> d </span><span class="token" style="color:#d4d4d4">=</span><span> </span><span class="token" style="color:#b5cea8">0</span><span class="token" style="color:#d4d4d4">;</span><span> d </span><span class="token" style="color:#d4d4d4">&lt;</span><span> dp</span><span class="token" style="color:#d4d4d4">[</span><span>i </span><span class="token" style="color:#d4d4d4">-</span><span> </span><span class="token" style="color:#b5cea8">1</span><span class="token" style="color:#d4d4d4">]</span><span class="token" style="color:#d4d4d4">.</span><span class="token property-access">length</span><span class="token" style="color:#d4d4d4">;</span><span> d</span><span class="token" style="color:#d4d4d4">++</span><span class="token" style="color:#d4d4d4">)</span><span> </span><span class="token" style="color:#d4d4d4">{</span><span>
</span><span>                </span><span class="token" style="color:#c586c0">if</span><span> </span><span class="token" style="color:#d4d4d4">(</span><span>d </span><span class="token" style="color:#d4d4d4">!=</span><span> j</span><span class="token" style="color:#d4d4d4">)</span><span> </span><span class="token" style="color:#d4d4d4">{</span><span>
</span><span>                    min </span><span class="token" style="color:#d4d4d4">=</span><span> </span><span class="token known-class-name" style="color:#4ec9b0">Math</span><span class="token" style="color:#d4d4d4">.</span><span class="token method property-access" style="color:#dcdcaa">min</span><span class="token" style="color:#d4d4d4">(</span><span>min </span><span class="token" style="color:#d4d4d4">??</span><span> dp</span><span class="token" style="color:#d4d4d4">[</span><span>i </span><span class="token" style="color:#d4d4d4">-</span><span> </span><span class="token" style="color:#b5cea8">1</span><span class="token" style="color:#d4d4d4">]</span><span class="token" style="color:#d4d4d4">[</span><span>d</span><span class="token" style="color:#d4d4d4">]</span><span class="token" style="color:#d4d4d4">,</span><span> dp</span><span class="token" style="color:#d4d4d4">[</span><span>i </span><span class="token" style="color:#d4d4d4">-</span><span> </span><span class="token" style="color:#b5cea8">1</span><span class="token" style="color:#d4d4d4">]</span><span class="token" style="color:#d4d4d4">[</span><span>d</span><span class="token" style="color:#d4d4d4">]</span><span class="token" style="color:#d4d4d4">)</span><span>
</span><span>                </span><span class="token" style="color:#d4d4d4">}</span><span>
</span><span>            </span><span class="token" style="color:#d4d4d4">}</span><span>
</span><span>            dp</span><span class="token" style="color:#d4d4d4">[</span><span>i</span><span class="token" style="color:#d4d4d4">]</span><span class="token" style="color:#d4d4d4">[</span><span>j</span><span class="token" style="color:#d4d4d4">]</span><span> </span><span class="token" style="color:#d4d4d4">=</span><span> min</span><span class="token" style="color:#d4d4d4">+</span><span>grid</span><span class="token" style="color:#d4d4d4">[</span><span>i</span><span class="token" style="color:#d4d4d4">]</span><span class="token" style="color:#d4d4d4">[</span><span>j</span><span class="token" style="color:#d4d4d4">]</span><span>
</span><span>        </span><span class="token" style="color:#d4d4d4">}</span><span>
</span><span>    </span><span class="token" style="color:#d4d4d4">}</span><span>
</span><span>    </span><span class="token" style="color:#c586c0">return</span><span> </span><span class="token known-class-name" style="color:#4ec9b0">Math</span><span class="token" style="color:#d4d4d4">.</span><span class="token method property-access" style="color:#dcdcaa">min</span><span class="token" style="color:#d4d4d4">(</span><span class="token spread" style="color:#d4d4d4">...</span><span>dp</span><span class="token" style="color:#d4d4d4">.</span><span class="token method property-access" style="color:#dcdcaa">pop</span><span class="token" style="color:#d4d4d4">(</span><span class="token" style="color:#d4d4d4">)</span><span class="token" style="color:#d4d4d4">)</span><span>
</span><span></span><span class="token" style="color:#d4d4d4">}</span><span class="token" style="color:#d4d4d4">;</span><span>
</span>
</code></pre></div></pre></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaData":{"title":"动态规划","description":"动态规划（Dynamic Programming）解决一些具有重叠子问题性质的问题。动态规划通常用于优化递归算法，通过将中间结果存储起来，避免重复计算同一个子问题","tags":["算法","动态规划"],"keywords":["算法","动态规划"],"id":"动态规划","create":1691979935551,"lastUpdate":1692155976006},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    h3: \"h3\",\n    pre: \"pre\",\n    code: \"code\",\n    blockquote: \"blockquote\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"动态规划\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"动态规划最核心的思想，就在于拆分子问题，记住过往，减少重复计算。\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"A ： \\\"1+1+1+1+1+1+1+1 =？\\\"\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"A ： \\\"上面等式的值是多少\\\"\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"B ： 计算 \\\"8\\\"\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"A : 在上面等式的左边写上 \\\"1+\\\" 呢？\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"A : \\\"此时等式的值为多少\\\"\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"B : 很快得出答案 \\\"9\\\"\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"A : \\\"你怎么这么快就知道答案了\\\"\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"A : \\\"只要在8的基础上加1就行了\\\"\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"A : \\\"所以你不用重新计算，因为你记住了第一个等式的值为8!动态规划算法也可以说是 '记住求过的解来节省时间'\\\"\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"斐波那契数列\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"指的是这样一个数列：这个数列从第3项开始，每一项都等于前两项之和。\\nF(0) = 0,F(1) = 1, F(n) = F(n - 1) + F(n - 2),\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js:动态规划-斐波那契数列\",\n        children: \"  function fibonacciDynamic(n) {\\n    if(n \u003c= 1 ) return n;\\n    let dp = [];\\n    dp[0] = 0; dp[1] = 1;\\n\\n    for(let i = 2;i \u003c= n; i++){\\n      dp[i] = dp[i-2]+dp[i-1]\\n    }\\n    return dp[n]\\n  }\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"青蛙跳阶问题\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"f(n) = f(n-1) + f(n-2)\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"对于一般情况的n，青蛙跳上第n级台阶有两种方式：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"青蛙\", _jsx(_components.code, {\n          children: \"从第n-1级台阶跳上来\"\n        }), \"：这种情况下，青蛙只需要从第n-1级台阶跳1级就能到达第n级台阶，所以这种方式的跳法数量为f(n-1)。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"青蛙\", _jsx(_components.code, {\n          children: \"从第n-2级台阶跳上来\"\n        }), \"：这种情况下，青蛙需要从第n-2级台阶跳2级才能到达第n级台阶，所以这种方式的跳法数量为f(n-2)。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"一只青蛙跳上n级的台阶有多少种跳法。\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"f(n) = 2*f(n-1)  |  2^(n-1)\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"下降路径最小和\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"给你一个 n x n 整数矩阵 grid ，请你返回 非零偏移下降路径 数字和的最小值。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"输入：grid = [[1,2,3],[4,5,6],[7,8,9]]\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"输出：13\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"解释：\\n所有非零偏移下降路径包括：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"[1,5,9], [1,5,7], [1,6,7], [1,6,8],\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"[2,4,8], [2,4,9], [2,6,7], [2,6,8],\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"[3,4,8], [3,4,9], [3,5,7], [3,5,9]\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"下降路径中数字和最小的是 [1,5,7] ，所以答案是 13 。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"解题思路:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"dp[i][j] 表示 第i行第j个元素的最小路径和\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"grid[i[j] 下降路径第i行第j个元素\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"dp[i][j] = dp[i-1][j] + grid[i[j]\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js:下降路径最小和\",\n        children: \"\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n * dp[i][j] 表示 第i行第j个元素的最小路径和\\n * dp[i][j] =min(dp[i-1][j])\\n */\\nfunction minFallingPathSum (grid) {\\n\\n    let dp = [[...grid[0]]]\\n    for (let i = 1; i \u003c grid.length; i++) {\\n        dp[i] = []\\n        for (let j = 0; j \u003c grid[i].length; j++) {\\n            let min;\\n            for (let d = 0; d \u003c dp[i - 1].length; d++) {\\n                if (d != j) {\\n                    min = Math.min(min ?? dp[i - 1][d], dp[i - 1][d])\\n                }\\n            }\\n            dp[i][j] = min+grid[i][j]\\n        }\\n    }\\n    return Math.min(...dp.pop())\\n};\\n\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/blog/detail/[id]","query":{"id":"动态规划"},"buildId":"HZJv74Pq-2_9EJ9ksPX8e","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>