<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>(*^▽^*)</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/3bf46ada9988a1ba.css" as="style"/><link rel="stylesheet" href="/_next/static/css/3bf46ada9988a1ba.css" data-n-g=""/><link rel="preload" href="/_next/static/css/f8f6338530cfd437.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f8f6338530cfd437.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee7e63bc15b31913.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-7477d36a73a3487c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d4a67795baa53afd.js" defer=""></script><script src="/_next/static/chunks/784-00c1e6d16e5c2f27.js" defer=""></script><script src="/_next/static/chunks/pages/blog/detail/%5Bid%5D-7068d1fed1a11860.js" defer=""></script><script src="/_next/static/4UT31DzBJHE4GG59AT5bt/_buildManifest.js" defer=""></script><script src="/_next/static/4UT31DzBJHE4GG59AT5bt/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="layout_main-container__jR90l"><main class="layout_main__E22hH"><div style="width:15em"><nav class="sidebar_nav__EFmKd"><div class="Avatar_container__egCID"><div class="Avatar_image-container__9WrGh"><img src="/images/avatar.png" alt="mingjianglong" class="Avatar_avatar__oORu6"/><h2>龙江</h2><h3 style="font-weight:normal;padding-top:.6em;color:grey">Jiang Long</h3><h4 style="padding-top:1.3em">等风也等你~</h4><span class="Avatar_my-face__hbhE_">ღゝ◡╹)ノ♡</span></div><div></div></div><a style="color:black" href="/">开心☺</a><a style="color:black" href="/blog">Blog</a><a style="color:black" href="/archive">归档</a><a style="color:black" href="/resume">简介</a></nav></div><div style="flex:1;height:100vh;display:flex;flex-direction:column;overflow-y:hidden"><div style="height:100%;padding:7em;overflow:scroll"><h1 style="font-family:&#x27;Ubuntu&#x27;, sans-serif;font-size:calc(1rem + 1.5vw);color:#1d2b35;padding:1em 0;overflow-wrap:break-word">友宝项目架构</h1>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">简单学习一下友宝的前端项目架构</p>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">友宝的前端项目的整体架构底层技术栈选用的是PHP+React，使用PHP做为外壳，内部重定向web静态资源。web资源请求首先经过的是PHP接口,经过一系列的中间件处理(比如鉴权之类...)，最后将页面展示需要的数据通过window对象注入静态页面，然后再将静态页面返回给浏览器渲染。</p>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">感觉整体架构的思路有点类似于服务端渲染的思想，每次页面请求都是经过的服务端接口，服务端再去决定返回什么资源，实际返回的是一个已经有数据的静态页面，但是没有经过渲染，只是有页面数据，还是需要客户端渲染。</p>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">优点</p>
<ul style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013e6;margin:1vh 0 1vh calc(2vw);overflow-wrap:break-word">
<li>前端开发不需要网络服务模块</li>
<li>服务端感知度低</li>
<li>将静态数据注入的方式，减小的客户端的压力</li>
<li>方便页面重定向，定制化页面(可以通过外壳统一做特定活动之类的)</li>
</ul>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">缺点</p>
<ul style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013e6;margin:1vh 0 1vh calc(2vw);overflow-wrap:break-word">
<li>前端依赖的数据都是注入在window对象，如果window对象被后续修改将获取不到内容</li>
<li>应用场景少，只能应用于不经常变化的数据。</li>
<li>前端开发BUG定位调试变得困难，开发环境虽然可mock数据，但是如果需要针对特定bug，修复bug发布之后才能看到修复结果。</li>
<li>前后端耦合</li>
</ul></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaData":{"title":"友宝项目架构","description":"简单学习一下友宝的前端项目架构","tags":["架构"],"keywords":["架构"],"id":"友宝项目架构","create":1682416219038,"lastUpdate":1686904275591},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"友宝项目架构\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"简单学习一下友宝的前端项目架构\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"友宝的前端项目的整体架构底层技术栈选用的是PHP+React，使用PHP做为外壳，内部重定向web静态资源。web资源请求首先经过的是PHP接口,经过一系列的中间件处理(比如鉴权之类...)，最后将页面展示需要的数据通过window对象注入静态页面，然后再将静态页面返回给浏览器渲染。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"感觉整体架构的思路有点类似于服务端渲染的思想，每次页面请求都是经过的服务端接口，服务端再去决定返回什么资源，实际返回的是一个已经有数据的静态页面，但是没有经过渲染，只是有页面数据，还是需要客户端渲染。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"优点\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"前端开发不需要网络服务模块\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"服务端感知度低\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"将静态数据注入的方式，减小的客户端的压力\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"方便页面重定向，定制化页面(可以通过外壳统一做特定活动之类的)\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"缺点\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"前端依赖的数据都是注入在window对象，如果window对象被后续修改将获取不到内容\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"应用场景少，只能应用于不经常变化的数据。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"前端开发BUG定位调试变得困难，开发环境虽然可mock数据，但是如果需要针对特定bug，修复bug发布之后才能看到修复结果。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"前后端耦合\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/blog/detail/[id]","query":{"id":"友宝项目架构"},"buildId":"4UT31DzBJHE4GG59AT5bt","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>