<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>(*^▽^*)</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/80a95484ea2876e6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/80a95484ea2876e6.css" data-n-g=""/><link rel="preload" href="/_next/static/css/f8f6338530cfd437.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f8f6338530cfd437.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee7e63bc15b31913.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-7477d36a73a3487c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d15f243f6b85624f.js" defer=""></script><script src="/_next/static/chunks/171-0943d13a71220321.js" defer=""></script><script src="/_next/static/chunks/pages/blog/detail/%5Bid%5D-0499978da9bd8e44.js" defer=""></script><script src="/_next/static/I9ToqXPByyPGgt-PQ6KV4/_buildManifest.js" defer=""></script><script src="/_next/static/I9ToqXPByyPGgt-PQ6KV4/_ssgManifest.js" defer=""></script><style id="__jsx-1471609662">.file-name-container.jsx-1471609662{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;width:100%;max-width:100%;background-color:#1d2b35d9;padding:-webkit-calc(.5rem + .2vw);padding:-moz-calc(.5rem + .2vw);padding:calc(.5rem + .2vw);-webkit-border-top-left-radius:5px;-moz-border-radius-topleft:5px;border-top-left-radius:5px;-webkit-border-top-right-radius:5px;-moz-border-radius-topright:5px;border-top-right-radius:5px;margin-top:1vh;white-space:pre-wrap;word-wrap:break-word;overflow-wrap:break-word}.file-name.jsx-1471609662{font-family:"Share Tech Mono",monospace;font-size:-webkit-calc(.9rem + .1vw);font-size:-moz-calc(.9rem + .1vw);font-size:calc(.9rem + .1vw);color:#fffecbf2}</style></head><body><div id="__next"><div class="layout_main-container__jR90l"><main class="layout_main__E22hH"><div style="width:15em"><nav class="sidebar_nav__EFmKd"><div class="Avatar_container__egCID"><div class="Avatar_image-container__9WrGh"><img src="/images/avatar.png" alt="mingjianglong" class="Avatar_avatar__oORu6"/><h2>龙江</h2><h3 style="font-weight:normal;padding-top:.6em;color:grey">Jiang Long</h3><h4 style="padding-top:1.3em">等风也等你~</h4><span class="Avatar_my-face__hbhE_">ღゝ◡╹)ノ♡</span></div><div></div></div><a style="color:black" href="/">开心☺</a><a style="color:black" href="/blog">Blog</a><a style="color:black" href="/archive">归档</a><a style="color:black" href="/resume">简介</a></nav></div><div style="flex:1;height:100vh;display:flex;flex-direction:column;overflow-y:hidden"><div style="height:100%;padding:7em;overflow:scroll"><h1 style="font-family:&#x27;Ubuntu&#x27;, sans-serif;font-size:calc(1rem + 1.5vw);color:#1d2b35;padding:1em 0;overflow-wrap:break-word">快速排序</h1>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">快速排序（Quick Sort）是一种常用的排序算法，其平均时间复杂度为O(nlogn)。在最坏情况下，时间复杂度为O(n^2)，但通过合理的选取主元 元素和随机化等方法，可以有效地避免最坏情况发生。</p>
<blockquote style="font-style:italic;background-color:#20a4f326;padding:10px;margin:1vh 0 1vh 0;border-left:5px solid #20a4f3e6">
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">快速排序的基本思想是通过划分（Partition）将数组分为两个子数组，其中一个子数组所有元素都小于等于主元（pivot），另一个子数组所有元素都大于等于主元，然后递归地对这两个子数组进行排序，直到子数组的长度为1或为空。</p>
</blockquote>
<h3 style="font-family:&#x27;Maven Pro&#x27;, sans-serif;font-size:calc(1rem + 0.5vw);color:#1d2b35;padding:.6em 0;overflow-wrap:break-word">优化点</h3>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">在每次划分过程中，选择合适的主元元素对数组进行划分是影响快速排序性能的关键。通常采用以下几种方式来选择主元元素：</p>
<ul style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013e6;margin:1vh 0 1vh calc(2vw);overflow-wrap:break-word">
<li>选取首元素、尾元素或者中间元素作为主元。</li>
<li>随机选择数组中的一个元素作为主元。</li>
<li>三数取中法，选择首、尾和中间位置的元素中值作为主元。</li>
</ul>
<h3 style="font-family:&#x27;Maven Pro&#x27;, sans-serif;font-size:calc(1rem + 0.5vw);color:#1d2b35;padding:.6em 0;overflow-wrap:break-word">时间复杂度</h3>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">快速排序的平均时间复杂度为O(nlogn)，这是由于每次划分操作都将数组划分为大致相等的两个子数组（除非数组中有重复元素，导致划分不均匀）。而每轮划分需要O(n)的时间复杂度，递归调用的次数为O(logn)。</p>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">然而，快速排序在最坏情况下的时间复杂度为O(n^2)，当数组已经有序或基本有序时，每次划分只能将规模减小1，此时快速排序退化为了一种冒泡排序。为了避免最坏情况的发生，可以通过随机选择主元、采用三数取中法等方法来提高算法的性能。</p>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">总结起来，快速排序的平均时间复杂度为O(nlogn)，在最坏情况下的时间复杂度为O(n^2)，并且它是一种原地排序算法，不需要额外的存储空间。</p>
<pre><div class="jsx-1471609662"><div class="jsx-1471609662 file-name-container"><p class="jsx-1471609662 file-name">快速排序</p></div><pre class="language-ts:快速排序" style="color:#1d2b35;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.2;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:0px;overflow:auto;background:#1e1e1e;background-color:#071013f2;padding-bottom:1em;margin-bottom:1vh;border-bottom-left-radius:5px;border-bottom-right-radius:5px"><code class="language-ts" style="color:#d4d4d4;font-size:calc(0.8rem + 0.1vw);text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.2;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>
</span><span>  </span><span class="token" style="color:#569CD6">let</span><span> arr </span><span class="token" style="color:#d4d4d4">=</span><span> </span><span class="token" style="color:#d4d4d4">[</span><span class="token" style="color:#b5cea8">5</span><span class="token" style="color:#d4d4d4">,</span><span class="token" style="color:#b5cea8">2</span><span class="token" style="color:#d4d4d4">,</span><span class="token" style="color:#b5cea8">1</span><span class="token" style="color:#d4d4d4">,</span><span class="token" style="color:#b5cea8">6</span><span class="token" style="color:#d4d4d4">,</span><span class="token" style="color:#b5cea8">8</span><span class="token" style="color:#d4d4d4">,</span><span class="token" style="color:#b5cea8">3</span><span class="token" style="color:#d4d4d4">,</span><span class="token" style="color:#b5cea8">2</span><span class="token" style="color:#d4d4d4">,</span><span class="token" style="color:#b5cea8">9</span><span class="token" style="color:#d4d4d4">,</span><span class="token" style="color:#b5cea8">2</span><span class="token" style="color:#d4d4d4">]</span><span>
</span><span>  </span><span class="token" style="color:#569CD6">function</span><span> </span><span class="token" style="color:#dcdcaa">sort</span><span class="token" style="color:#d4d4d4">(</span><span>arr</span><span class="token" style="color:#d4d4d4">:</span><span class="token" style="color:#ce9178">number</span><span class="token" style="color:#d4d4d4">[</span><span class="token" style="color:#d4d4d4">]</span><span class="token" style="color:#d4d4d4">)</span><span class="token" style="color:#d4d4d4">{</span><span>
</span><span>    </span><span class="token" style="color:#c586c0">if</span><span class="token" style="color:#d4d4d4">(</span><span>arr</span><span class="token" style="color:#d4d4d4">.</span><span class="token property-access">length</span><span class="token" style="color:#d4d4d4">&lt;=</span><span class="token" style="color:#b5cea8">1</span><span class="token" style="color:#d4d4d4">)</span><span> </span><span class="token" style="color:#c586c0">return</span><span> arr</span><span class="token" style="color:#d4d4d4">;</span><span>
</span><span>    </span><span class="token" style="color:#569CD6">const</span><span> base </span><span class="token" style="color:#d4d4d4">=</span><span> arr</span><span class="token" style="color:#d4d4d4">.</span><span class="token method property-access" style="color:#dcdcaa">pop</span><span class="token" style="color:#d4d4d4">(</span><span class="token" style="color:#d4d4d4">)</span><span class="token" style="color:#d4d4d4">;</span><span>
</span><span>    </span><span class="token" style="color:#569CD6">let</span><span> left </span><span class="token" style="color:#d4d4d4">=</span><span> </span><span class="token" style="color:#d4d4d4">[</span><span class="token" style="color:#d4d4d4">]</span><span class="token" style="color:#d4d4d4">;</span><span>
</span><span>    </span><span class="token" style="color:#569CD6">let</span><span> right </span><span class="token" style="color:#d4d4d4">=</span><span> </span><span class="token" style="color:#d4d4d4">[</span><span class="token" style="color:#d4d4d4">]</span><span>
</span><span>    arr</span><span class="token" style="color:#d4d4d4">.</span><span class="token method property-access" style="color:#dcdcaa">forEach</span><span class="token" style="color:#d4d4d4">(</span><span>item</span><span class="token" style="color:#569CD6">=&gt;</span><span class="token" style="color:#d4d4d4">{</span><span>
</span><span>      </span><span class="token" style="color:#c586c0">if</span><span class="token" style="color:#d4d4d4">(</span><span>item </span><span class="token" style="color:#d4d4d4">&lt;</span><span> base</span><span class="token" style="color:#d4d4d4">)</span><span class="token" style="color:#d4d4d4">{</span><span>
</span><span>        left</span><span class="token" style="color:#d4d4d4">.</span><span class="token method property-access" style="color:#dcdcaa">push</span><span class="token" style="color:#d4d4d4">(</span><span>item</span><span class="token" style="color:#d4d4d4">)</span><span>
</span><span>      </span><span class="token" style="color:#d4d4d4">}</span><span class="token" style="color:#c586c0">else</span><span class="token" style="color:#d4d4d4">{</span><span>
</span><span>        right</span><span class="token" style="color:#d4d4d4">.</span><span class="token method property-access" style="color:#dcdcaa">push</span><span class="token" style="color:#d4d4d4">(</span><span>item</span><span class="token" style="color:#d4d4d4">)</span><span>
</span><span>      </span><span class="token" style="color:#d4d4d4">}</span><span>
</span><span>    </span><span class="token" style="color:#d4d4d4">}</span><span class="token" style="color:#d4d4d4">)</span><span>
</span><span>    </span><span class="token" style="color:#c586c0">return</span><span> </span><span class="token" style="color:#d4d4d4">[</span><span class="token spread" style="color:#d4d4d4">...</span><span class="token method property-access" style="color:#dcdcaa">sort</span><span class="token" style="color:#d4d4d4">(</span><span>left</span><span class="token" style="color:#d4d4d4">)</span><span class="token" style="color:#d4d4d4">,</span><span>base</span><span class="token" style="color:#d4d4d4">,</span><span class="token spread" style="color:#d4d4d4">...</span><span class="token method property-access" style="color:#dcdcaa">sort</span><span class="token" style="color:#d4d4d4">(</span><span>right</span><span class="token" style="color:#d4d4d4">)</span><span class="token" style="color:#d4d4d4">]</span><span>
</span><span>  </span><span class="token" style="color:#d4d4d4">}</span><span>
</span></code></pre></div></pre></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaData":{"title":"快速排序","description":"快速排序","tags":["算法","排序"],"keywords":["算法","排序"],"id":"快速排序","create":1691743637451,"lastUpdate":1692078420654},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    blockquote: \"blockquote\",\n    h3: \"h3\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"快速排序\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"快速排序（Quick Sort）是一种常用的排序算法，其平均时间复杂度为O(nlogn)。在最坏情况下，时间复杂度为O(n^2)，但通过合理的选取主元 元素和随机化等方法，可以有效地避免最坏情况发生。\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"快速排序的基本思想是通过划分（Partition）将数组分为两个子数组，其中一个子数组所有元素都小于等于主元（pivot），另一个子数组所有元素都大于等于主元，然后递归地对这两个子数组进行排序，直到子数组的长度为1或为空。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"优化点\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在每次划分过程中，选择合适的主元元素对数组进行划分是影响快速排序性能的关键。通常采用以下几种方式来选择主元元素：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"选取首元素、尾元素或者中间元素作为主元。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"随机选择数组中的一个元素作为主元。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"三数取中法，选择首、尾和中间位置的元素中值作为主元。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"时间复杂度\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"快速排序的平均时间复杂度为O(nlogn)，这是由于每次划分操作都将数组划分为大致相等的两个子数组（除非数组中有重复元素，导致划分不均匀）。而每轮划分需要O(n)的时间复杂度，递归调用的次数为O(logn)。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"然而，快速排序在最坏情况下的时间复杂度为O(n^2)，当数组已经有序或基本有序时，每次划分只能将规模减小1，此时快速排序退化为了一种冒泡排序。为了避免最坏情况的发生，可以通过随机选择主元、采用三数取中法等方法来提高算法的性能。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"总结起来，快速排序的平均时间复杂度为O(nlogn)，在最坏情况下的时间复杂度为O(n^2)，并且它是一种原地排序算法，不需要额外的存储空间。\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts:快速排序\",\n        children: \"\\n  let arr = [5,2,1,6,8,3,2,9,2]\\n  function sort(arr:number[]){\\n    if(arr.length\u003c=1) return arr;\\n    const base = arr.pop();\\n    let left = [];\\n    let right = []\\n    arr.forEach(item=\u003e{\\n      if(item \u003c base){\\n        left.push(item)\\n      }else{\\n        right.push(item)\\n      }\\n    })\\n    return [...sort(left),base,...sort(right)]\\n  }\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/blog/detail/[id]","query":{"id":"快速排序"},"buildId":"I9ToqXPByyPGgt-PQ6KV4","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>