<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>(*^▽^*)</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/80a95484ea2876e6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/80a95484ea2876e6.css" data-n-g=""/><link rel="preload" href="/_next/static/css/f8f6338530cfd437.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f8f6338530cfd437.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee7e63bc15b31913.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-7477d36a73a3487c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d15f243f6b85624f.js" defer=""></script><script src="/_next/static/chunks/171-0943d13a71220321.js" defer=""></script><script src="/_next/static/chunks/pages/blog/detail/%5Bid%5D-0499978da9bd8e44.js" defer=""></script><script src="/_next/static/iljR5K2S48uEKU28Vx8yC/_buildManifest.js" defer=""></script><script src="/_next/static/iljR5K2S48uEKU28Vx8yC/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="layout_main-container__jR90l"><main class="layout_main__E22hH"><div style="width:15em"><nav class="sidebar_nav__EFmKd"><div class="Avatar_container__egCID"><div class="Avatar_image-container__9WrGh"><img src="/images/avatar.png" alt="mingjianglong" class="Avatar_avatar__oORu6"/><h2>龙江</h2><h3 style="font-weight:normal;padding-top:.6em;color:grey">Jiang Long</h3><h4 style="padding-top:1.3em">等风也等你~</h4><span class="Avatar_my-face__hbhE_">ღゝ◡╹)ノ♡</span></div><div></div></div><a style="color:black" href="/">开心☺</a><a style="color:black" href="/blog">Blog</a><a style="color:black" href="/archive">归档</a><a style="color:black" href="/resume">简介</a></nav></div><div style="flex:1;height:100vh;display:flex;flex-direction:column;overflow-y:hidden"><div style="height:100%;padding:7em;overflow:scroll"><h1 style="font-family:&#x27;Ubuntu&#x27;, sans-serif;font-size:calc(1rem + 1.5vw);color:#1d2b35;padding:1em 0;overflow-wrap:break-word">数据库设计之字段冗余</h1>
<h3 style="font-family:&#x27;Maven Pro&#x27;, sans-serif;font-size:calc(1rem + 0.5vw);color:#1d2b35;padding:.6em 0;overflow-wrap:break-word">数据库设计规范</h3>
<blockquote style="font-style:italic;background-color:#20a4f326;padding:10px;margin:1vh 0 1vh 0;border-left:5px solid #20a4f3e6">
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">数据库三范式（Third Normal Form，3NF）是关系型数据库设计中的一种规范化标准，旨在减少数据冗余和提高数据的一致性</p>
</blockquote>
<ul style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013e6;margin:1vh 0 1vh calc(2vw);overflow-wrap:break-word">
<li>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">第一范式（1NF）：确保每个列都是原子性的，即每列的值都是不可再分的。这意味着每个列中不能包含多个值或重复的值。</p>
</li>
<li>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">第二范式（2NF）：在满足第一范式的基础上，要求非主键属性完全依赖于主键，而不是部分依赖。换句话说，表中的每个非主键字段都必须完全依赖于整个主键，而不是只依赖于主键中的一部分。</p>
</li>
<li>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">第三范式（3NF）：在满足第二范式的基础上，要求消除传递依赖，即任何非主键字段不应该依赖于其他非主键字段。如果存在这样的依赖关系，应该将其移动到一个独立的表中。</p>
</li>
</ul>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">通过遵守三范式，可以减少数据冗余，提高数据的一致性和更新操作的效率。但需要注意的是，在某些情况下，过度规范化可能会导致查询操作复杂化和性能下降。因此，在设计数据库时需要权衡范式化的程度，根据具体的业务需求和性能要求做出决策。</p>
<h3 style="font-family:&#x27;Maven Pro&#x27;, sans-serif;font-size:calc(1rem + 0.5vw);color:#1d2b35;padding:.6em 0;overflow-wrap:break-word">是否使用冗余字段需要考虑的因素</h3>
<ul style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013e6;margin:1vh 0 1vh calc(2vw);overflow-wrap:break-word">
<li>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">数据一致性：冗余字段可能导致数据的不一致性，当更新一个表中的数据时，必须确保所有相关的表中的冗余字段也被正确更新。这增加了复杂性和风险。</p>
</li>
<li>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">存储开销：使用冗余字段会占用更多的存储空间。对于大型数据库、高负载系统或者存储成本较高的环境，需要仔细考虑冗余字段的使用。</p>
</li>
<li>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">数据查询性能：通过冗余字段可以减少关联操作，提高查询性能。当经常需要关联查询操作时，可以考虑使用冗余字段来避免频繁的表连接操作。</p>
</li>
<li>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">数据更新性能：使用冗余字段可以减少更新操作的复杂性和耗时性。当数据的读取次数远远超过写入次数时，可以考虑使用冗余字段来提高写入性能。</p>
</li>
<li>
<p style="font-family:&#x27;Source Sans Pro&#x27;, sans-serif;font-size:calc(1rem + 0.1vw);color:#071013f2;margin:0vh 0 1vh 0;overflow-wrap:break-word">数据一致性维护成本：冗余字段的存在会增加数据一致性维护的成本。如果修改了冗余字段的值，必须确保所有相关的冗余字段都得到更新，否则会导致数据不一致。</p>
</li>
</ul></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metaData":{"title":"数据库设计之字段冗余","description":"数据库设计之字段冗余","tags":["mysql"],"keywords":["mysql"],"id":"数据库冗余数据","create":1693450965148,"lastUpdate":1702540583290},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    h3: \"h3\",\n    blockquote: \"blockquote\",\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"数据库设计之字段冗余\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"数据库设计规范\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"数据库三范式（Third Normal Form，3NF）是关系型数据库设计中的一种规范化标准，旨在减少数据冗余和提高数据的一致性\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"第一范式（1NF）：确保每个列都是原子性的，即每列的值都是不可再分的。这意味着每个列中不能包含多个值或重复的值。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"第二范式（2NF）：在满足第一范式的基础上，要求非主键属性完全依赖于主键，而不是部分依赖。换句话说，表中的每个非主键字段都必须完全依赖于整个主键，而不是只依赖于主键中的一部分。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"第三范式（3NF）：在满足第二范式的基础上，要求消除传递依赖，即任何非主键字段不应该依赖于其他非主键字段。如果存在这样的依赖关系，应该将其移动到一个独立的表中。\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"通过遵守三范式，可以减少数据冗余，提高数据的一致性和更新操作的效率。但需要注意的是，在某些情况下，过度规范化可能会导致查询操作复杂化和性能下降。因此，在设计数据库时需要权衡范式化的程度，根据具体的业务需求和性能要求做出决策。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"是否使用冗余字段需要考虑的因素\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"数据一致性：冗余字段可能导致数据的不一致性，当更新一个表中的数据时，必须确保所有相关的表中的冗余字段也被正确更新。这增加了复杂性和风险。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"存储开销：使用冗余字段会占用更多的存储空间。对于大型数据库、高负载系统或者存储成本较高的环境，需要仔细考虑冗余字段的使用。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"数据查询性能：通过冗余字段可以减少关联操作，提高查询性能。当经常需要关联查询操作时，可以考虑使用冗余字段来避免频繁的表连接操作。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"数据更新性能：使用冗余字段可以减少更新操作的复杂性和耗时性。当数据的读取次数远远超过写入次数时，可以考虑使用冗余字段来提高写入性能。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"数据一致性维护成本：冗余字段的存在会增加数据一致性维护的成本。如果修改了冗余字段的值，必须确保所有相关的冗余字段都得到更新，否则会导致数据不一致。\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/blog/detail/[id]","query":{"id":"数据库冗余数据"},"buildId":"iljR5K2S48uEKU28Vx8yC","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>