(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[405],{808:function(n,e,r){(window.__NEXT_P=window.__NEXT_P||[]).push(["/archive",function(){return r(6010)}])},3820:function(n){"use strict";n.exports=[{id:5,title:"NextJS打包配置学习",desc:"NextJS打包配置对应字段了解，进行简单的打包测试",tag:["Next","next.config.js"],content:'# NextJS打包配置学习\r\n\r\nNextJS打包配置对应字段了解，进行简单的打包测试\r\n<!-- [Next,next.config.js] -->\r\n> `assetPrefix` 静态资源前缀\r\n```js\r\n  const nextConfig = {\r\n    assetPrefix:\'/前缀\'\r\n  }\r\n```\r\n\r\n> `Redirects` 将source原路径重定向到destination新路径，访问的是destination路径;\r\n```JS\r\n// 最终访问的是/blog路径,浏览器显示的也是blog路径\r\nconst nextConfig = {\r\n  redirects() {\r\n    return [\r\n      {\r\n        source: "/",\r\n        destination: "/blog",\r\n        permanent: true\r\n      }\r\n    ]\r\n  },\r\n}\r\n```\r\n> `Rewrites`  将原路径充当代理以此来屏蔽目标路径。浏览器显示的是destination路径，实际访问的是source路径；功能类似于**userRouter.push(path,as)**中 参数**as**的功能;\r\n```JS\r\n// 浏览器显示的是"/blog"，实际访问的是"/"路径\r\nconst nextConfig = {\r\n  async rewrites() {\r\n    return [\r\n      {\r\n        source: \'/\',\r\n        destination: \'/blog\'\r\n      }\r\n    ]\r\n  },\r\n}\r\n```',createTime:1680086962261,lastUpdateTime:1680086962261},{id:6,title:"React搞笑记录",desc:"记录一些别人或者自己的React搞笑代码",tag:["React","Bug"],content:"# React搞笑记录\r\n\r\n记录一些别人或者自己的React搞笑代码\r\n\r\n<!-- [React,Bug] -->\r\n```JS\r\n\r\n const downTime = useCallback(\r\n    () => {\r\n      let b = 0\r\n      const Time = setInterval(() => {\r\n        if (b >1) {\r\n          clearInterval(Time)\r\n          return false\r\n        }\r\n        b++\r\n        handleGetVideo()\r\n      }, 2 * 1000 * 60)\r\n    },\r\n    [],\r\n  )\r\n\r\n  const handleGetVideo = () => {\r\n    getOrderVideo({ transactionId: id }).then(res => {\r\n      if (res && res.code == 200 && res.data) {\r\n        const {status,videoInfos}=res.data\r\n        if(status&&status=='FAILED'){\r\n          // ...\r\n        }else if(status&&status=='SUCCESS'&& videoInfos&&videoInfos.length){\r\n          // ...\r\n        }else if(status&&status=='QUERYING'){\r\n          setawaitState(true)\r\n          downTime()\r\n          setTimeout(() => {\r\n            setawaitState(false)\r\n          }, 2 * 1000 * 60)\r\n        }\r\n        \r\n      }\r\n    })\r\n  }\r\n```",createTime:1680086962261,lastUpdateTime:1680086962261},{id:2,title:"NextJS打包相关问题",desc:"NextJS打包相关问题以及解决办法，更多参见[Next文档](https://www.nextjs.cn/)",tag:["Next","打包"],content:"# NextJS打包相关问题\r\n\r\nNextJS打包相关问题以及解决办法，更多参见[Next文档](https://www.nextjs.cn/)\r\n<!-- [Next,打包] -->\r\n\r\n>Eslint、Ts类型校验关闭\r\n```js\r\n  // next.config.js\r\n\r\n  const nextConfig = {\r\n  \r\n    eslint:{\r\n      ignoreDuringBuilds:true\r\n    },\r\n      typescript: {\r\n      // !! WARN !!\r\n      // Dangerously allow production builds to successfully complete even if\r\n      // your project has type errors.\r\n      // !! WARN !!\r\n      ignoreBuildErrors: true,\r\n    }\r\n  }\r\n```\r\n\r\n\r\n\r\n> Image Optimization using Next.js' default loader is not compatible with `next export`.\r\n\r\n```JS\r\nmodule.exports = {\r\n  // https://github.com/vercel/next.js/issues/21079\r\n  // Remove this workaround whenever the issue is fixed\r\n  images: {\r\n    loader: 'imgix',\r\n    path: '',\r\n  },\r\n}\r\n```\r\n\r\n> 图片加载不出来",createTime:1680054331847,lastUpdateTime:1680086543112,tags:["Next","打包"]},{id:4,title:"友宝项目架构",desc:"简单学习一下友宝的前端项目架构",tag:["友宝","架构"],content:"# 友宝项目架构\r\n简单学习一下友宝的前端项目架构\r\n\r\n<!-- [友宝,架构] -->\r\n友宝的前端项目的整体架构底层技术栈选用的是PHP+React，使用PHP做为外壳，内部重定向web静态资源。web资源请求首先经过的是PHP接口,经过一系列的中间件处理(比如鉴权之类...)，最后将页面展示需要的数据通过window对象注入静态页面，然后再将静态页面返回给浏览器渲染。\r\n\r\n感觉整体架构的思路有点类似于服务端渲染的思想，每次页面请求都是经过的服务端接口，服务端再去决定返回什么资源，实际返回的是一个已经有数据的静态页面，但是没有经过渲染，只是有页面数据，还是需要客户端渲染。\r\n\r\n优点\r\n\r\n  * 前端开发不需要网络服务模块\r\n  * 服务端感知度低\r\n  * 将静态数据注入的方式，减小的客户端的压力\r\n  * 方便页面重定向，定制化页面(可以通过外壳统一做特定活动之类的)\r\n\r\n\r\n\r\n缺点\r\n\r\n  * 前端依赖的数据都是注入在window对象，如果window对象被后续修改将获取不到内容\r\n  * 应用场景少，只能应用于不经常变化的数据。\r\n  * 前端开发BUG定位调试变得困难，开发环境虽然可mock数据，但是如果需要针对特定bug，修复bug发布之后才能看到修复结果。\r\n  * 前后端耦合\r\n",createTime:1680054331856,lastUpdateTime:1680054331856},{id:3,title:"Blog",desc:"记录开发日常,ε=(\xb4ο｀*)))唉太难了，找工作总是有傻屌问我有没有blog",tag:["吐槽"],content:"# Blog\n\n记录开发日常,ε=(\xb4ο｀*)))唉太难了，找工作总是有傻屌问我有没有blog\n<!-- [吐槽] -->\n## Getting Started\n\n项目MD文件需要放在`/blogs`目录下，执行`/savaBlogs.js`会遍历blogs目录下所有md文件并格式化成json放在`/data/index.js`文件中;\nmd文件需要遵循一定的规则：\n* 首行标题 `# 标题`\n* 标题后紧跟MD文件简述 \n* 文章标签格式:`<!-- [标签1,标签2] -->`\n\n  ```\n    # 标题\n    我是文章描述\n    <!-- [标签1,标签2] -->\n    \n  ```\n项目运行\n```bash\nnpm install\nnpm run dev\n# or\nyarn dev\n# or\npnpm dev\n```\n",createTime:1680054331851,lastUpdateTime:1680054331851},{id:1,title:"Git常用操作",desc:"git常用命令记录，主要是容易忘",tag:["git"],content:"# Git常用操作\r\n\r\ngit常用命令记录，主要是容易忘\r\n\r\n<!-- [git] -->\r\n\r\n>`git pull -f origin master:master`\r\n  如果远程分支和本地分支代码相差太大，可以考虑用远程的覆盖本地代码",createTime:1680054331840,lastUpdateTime:1680054331840}]},6010:function(n,e,r){"use strict";r.r(e),r.d(e,{default:function(){return d}});var t=r(8598),i=r(2691),s=r.n(i),a=r(2684),o=r(3820),c=r.n(o);function d(){let[n,e]=(0,a.useState)([]);return(0,a.useEffect)(()=>{let n;let r=(n=[],c().forEach(e=>{let{tag:r}=e;r.forEach(r=>{let t=n.find(n=>n.typeName===r),i={id:e.id,title:e.title};t?t.children.push(i):n.push({typeName:r,children:[i]})})}),n);e(r)},[]),(0,t.jsx)("div",{style:{margin:"5em"},children:n.map((n,e)=>(0,t.jsxs)("div",{style:{marginTop:"2em"},children:[(0,t.jsx)("h3",{children:n.typeName}),(0,t.jsx)(t.Fragment,{children:n.children.map((n,e)=>(0,t.jsx)(s(),{style:{display:"block",fontSize:"1em",textDecorationLine:"underline",paddingTop:10,paddingLeft:20},href:"/blog/detail/".concat(n.id),children:n.title},"".concat(n.title,"_").concat(n.id,"_").concat(e)))})]},e))})}}},function(n){n.O(0,[774,888,179],function(){return n(n.s=808)}),_N_E=n.O()}]);