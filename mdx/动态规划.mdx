---
title: 动态规划
description: >-
  动态规划（Dynamic
  Programming）解决一些具有重叠子问题性质的问题。动态规划通常用于优化递归算法，通过将中间结果存储起来，避免重复计算同一个子问题
tags:
  - 算法
  - 动态规划
keywords:
  - 算法
  - 动态规划
id: 动态规划
create: 1691979935551
lastUpdate: 1691979935897
---

# 动态规划

动态规划最核心的思想，就在于拆分子问题，记住过往，减少重复计算。

- A ： "1+1+1+1+1+1+1+1 =？"
- A ： "上面等式的值是多少"
- B ： 计算 "8"
- A : 在上面等式的左边写上 "1+" 呢？
- A : "此时等式的值为多少"
- B : 很快得出答案 "9"
- A : "你怎么这么快就知道答案了"
- A : "只要在8的基础上加1就行了"
- A : "所以你不用重新计算，因为你记住了第一个等式的值为8!动态规划算法也可以说是 '记住求过的解来节省时间'"

### 斐波那契数列

指的是这样一个数列：这个数列从第3项开始，每一项都等于前两项之和。
F(0) = 0,F(1) = 1, F(n) = F(n - 1) + F(n - 2),

```js:动态规划-斐波那契数列
  function fibonacciDynamic(n) {
    if(n <= 1 ) return n;
    let dp = [];
    dp[0] = 0; dp[1] = 1;

    for(let i = 2;i <= n; i++){
      dp[i] = dp[i-2]+dp[i-1]
    }
    return dp[n]
  }
```

### 青蛙跳阶问题

- 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
> f(n) = f(n-1) + f(n-2)

  对于一般情况的n，青蛙跳上第n级台阶有两种方式：
  - 青蛙`从第n-1级台阶跳上来`：这种情况下，青蛙只需要从第n-1级台阶跳1级就能到达第n级台阶，所以这种方式的跳法数量为f(n-1)。
  - 青蛙`从第n-2级台阶跳上来`：这种情况下，青蛙需要从第n-2级台阶跳2级才能到达第n级台阶，所以这种方式的跳法数量为f(n-2)。


一只青蛙跳上n级的台阶有多少种跳法。

> f(n) = 2*f(n-1)  |  2^(n-1)

### 下降路径最小和

给你一个 n x n 整数矩阵 grid ，请你返回 非零偏移下降路径 数字和的最小值。

输入：grid = [[1,2,3],[4,5,6],[7,8,9]]

输出：13

解释：
所有非零偏移下降路径包括：

[1,5,9], [1,5,7], [1,6,7], [1,6,8],

[2,4,8], [2,4,9], [2,6,7], [2,6,8],

[3,4,8], [3,4,9], [3,5,7], [3,5,9]

下降路径中数字和最小的是 [1,5,7] ，所以答案是 13 。

解题思路:

dp[i][j] 表示 第i行第j个元素的最小路径和

grid[i[j] 下降路径第i行第j个元素

>dp[i][j] = dp[i-1][j] + grid[i[j]

```js:下降路径最小和

/**
 * @param {number[][]} grid
 * @return {number}
 * dp[i][j] 表示 第i行第j个元素的最小路径和
 * dp[i][j] =min(dp[i-1][j])
 */
function minFallingPathSum (grid) {

    let dp = [[...grid[0]]]
    for (let i = 1; i < grid.length; i++) {
        dp[i] = []
        for (let j = 0; j < grid[i].length; j++) {
            let min;
            for (let d = 0; d < dp[i - 1].length; d++) {
                if (d != j) {
                    min = Math.min(min ?? dp[i - 1][d], dp[i - 1][d])
                }
            }
            dp[i][j] = min+grid[i][j]
        }
    }
    return Math.min(...dp.pop())
};

```





  




