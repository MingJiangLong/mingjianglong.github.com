---
title: 快速排序
description: 快速排序
tags:
  - 算法
  - 排序
keywords:
  - 算法
  - 排序
id: 快速排序
create: 1691743637451
lastUpdate: 1691743638378
---

# 快速排序

  快速排序（Quick Sort）是一种常用的排序算法，其平均时间复杂度为O(nlogn)。在最坏情况下，时间复杂度为O(n^2)，但通过合理的选取主元 元素和随机化等方法，可以有效地避免最坏情况发生。

> 快速排序的基本思想是通过划分（Partition）将数组分为两个子数组，其中一个子数组所有元素都小于等于主元（pivot），另一个子数组所有元素都大于等于主元，然后递归地对这两个子数组进行排序，直到子数组的长度为1或为空。

### 优化点
在每次划分过程中，选择合适的主元元素对数组进行划分是影响快速排序性能的关键。通常采用以下几种方式来选择主元元素：

- 选取首元素、尾元素或者中间元素作为主元。
- 随机选择数组中的一个元素作为主元。
- 三数取中法，选择首、尾和中间位置的元素中值作为主元。

### 时间复杂度

快速排序的平均时间复杂度为O(nlogn)，这是由于每次划分操作都将数组划分为大致相等的两个子数组（除非数组中有重复元素，导致划分不均匀）。而每轮划分需要O(n)的时间复杂度，递归调用的次数为O(logn)。

然而，快速排序在最坏情况下的时间复杂度为O(n^2)，当数组已经有序或基本有序时，每次划分只能将规模减小1，此时快速排序退化为了一种冒泡排序。为了避免最坏情况的发生，可以通过随机选择主元、采用三数取中法等方法来提高算法的性能。

总结起来，快速排序的平均时间复杂度为O(nlogn)，在最坏情况下的时间复杂度为O(n^2)，并且它是一种原地排序算法，不需要额外的存储空间。

```ts:快速排序

  let arr = [5,2,1,6,8,3,2,9,2]
  function sort(arr:number[]){
    if(arr.length<=1) return arr;
    const base = arr.pop();
    let left = [];
    let right = []
    arr.forEach(item=>{
      if(item < base){
        left.push(item)
      }else{
        right.push(item)
      }
    })
    return [...sort(left),base,...sort(right)]
  }
```
